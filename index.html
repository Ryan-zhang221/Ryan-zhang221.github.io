<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/15/h5-c3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/h5-c3/" class="post-title-link" itemprop="url">h5+c3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-15 23:47:59 / Modified: 23:48:24" itemprop="dateCreated datePublished" datetime="2020-11-15T23:47:59+08:00">2020-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="浏览器处理一个url的步骤"><a href="#浏览器处理一个url的步骤" class="headerlink" title="浏览器处理一个url的步骤"></a>浏览器处理一个url的步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果输入的是一个ip地址，则直接去找对应的服务器</span><br><span class="line">&gt; 如果输入的是一个网址，先进行DNS解析，然后会在首先在 C:\Windows\System32\drivers\etc\hosts 目录下查找有没有对应的ip地址，如果有，则优先访问hosts文件中该网址对应的ip地址，如果没有，则回去DNS服务器上去找该网址对应的ip地址</span><br><span class="line">&gt; TCP连接</span><br><span class="line">&gt; HTTP请求</span><br><span class="line">&gt; 浏览器引擎渲染显示</span><br></pre></td></tr></table></figure>
<h2 id="URL的拆分"><a href="#URL的拆分" class="headerlink" title="URL的拆分"></a>URL的拆分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一个完整的URL： http:&#x2F;&#x2F;127.0.0.1:80&#x2F;index.html</span><br><span class="line">&gt; http:&#x2F;&#x2F; 指的是URL的协议类型</span><br><span class="line">&gt; 127.0.0.1 或者 www.jianshu.com 服务器IP地址或者域名</span><br><span class="line">&gt; :80 指的是服务器的端口号</span><br><span class="line">&gt; index.html 指的是需要访问的资源名称</span><br><span class="line">    &gt; IP地址相当于现实生活中的地址，例如：XX省XX市XX区XX小区</span><br><span class="line">    &gt; 端口号就相当于现实生活中的门牌号：例如：X号楼XX室</span><br><span class="line">    &gt; IP地址和端口号的作用就是告诉浏览器我们需要访问的那台服务器的详细地址是什么</span><br></pre></td></tr></table></figure>
<h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; H系列标签（6个，h1~h6，独占一行，企业项目一个页面只有一个h1，和SEO有关）</span><br><span class="line">&gt; hr标签（&lt;hr &#x2F;&gt;，自结束标签，一条分割线，width&#x3D;&#39;40px&#39;设置线条宽度）</span><br><span class="line">&gt; br标签（&lt;br&gt;，换行标签）</span><br><span class="line">&gt; p标签（一个段落，独占一行）</span><br><span class="line">&gt; h5新增语义化标签（artical，header，footer，nav，aside，section）</span><br><span class="line">&gt; span（不独占一行）</span><br><span class="line">&gt; img标签（src放地址&#39;绝对相对网络都可&#39;，alt图片未显示时的文本，title鼠标移入显示文本且所有标签都可用，不独占一行，行内元素，不想让图片变形宽高设置其一即可）</span><br><span class="line">&gt; a标签（链接，href属性为地址&#39;本地或远程&#39;，a中也可加图片，href如果为URL地址则必须有http:&#x2F;&#x2F;或https:&#x2F;&#x2F;，target属性值为&#39;_self&#39;指当前页面跳转为&#39;_blank&#39;指重新开一个空白页面跳转当前页面不动，href值为#时表示让页面跳到页面顶部！！！如果#后面加上某个标签的id值就可以跳到该标签的位置！！！甚至可以跳转到另一个文件的指定位置，href值为javascript:;时表示假链接任何操作都不做）</span><br><span class="line">&gt; ul&gt;li列表标签（无序ul，有序ol）</span><br><span class="line">&gt; dl&gt;dt&gt;dd列表标签（自定义一些列表）</span><br><span class="line">&gt; table表格标签（tr表示一行其中包着td，td表示每一行中有几个方块，宽高可以给table和td使用，align属性设置水平对齐方式table tr td都可使用，valign属性设置垂直对齐方式tr td可设置，cellspacing单元格之间的距离只能给table设置，cellpadding设置内边距，bgcolor可用于table tr td）</span><br><span class="line">    &gt; 注意如果想要想要实现细线表格，让外边距为0是不会实现的，必须要：给table设置bgcolor，给tr设置bgcolor，给table设置cellspacing&#x3D;&quot;1px&quot;即可实现</span><br><span class="line">    &gt; 如何添加表格标题：使用&lt;caption&gt;标签，该标签一定要写在table标签中，且紧跟在table后面，否则无效</span><br><span class="line">    &gt; th标签可以用来替换掉td标签，它是用来写列表标题的，会自动加粗居中文字</span><br><span class="line">    &gt; 合并单元格：给td标签中写入 colspan 和 rowspan </span><br><span class="line">&gt; 表单元素（form，其中action属性可以写入URL来指定form中input按钮的跳转）</span><br><span class="line">&gt; input标签（input中的type属性有许多值，分别表示不同的输入框样式：text明文输入框，password暗文输入框，radio单选框，checkbox多选框，button定义普通按钮如果要写按钮文字用value&#x3D;&#39;XX&#39;，image图片按钮，reset重置按钮，submit提交按钮可以跳转到form表单中的action属性指定的地址中去，hidden隐藏域用户无法看到，统一给input加上value值就会改变按钮中的文字内容）</span><br><span class="line">    &gt; 如果想要在URL的?后面拼接上input中的值，就需要给input输入框指定name属性，拼接成功之后就是?name&#x3D;value 即可完成拼接，name就是告诉浏览器其中是什么</span><br><span class="line">    &gt; input框中对特定的type值可以进行相应的判断，如果格式不对则不会提交，同样需要输入name属性值，可以验证的属性都有email,url,number,date,color，给这几种type属性的input框可以加上label标签，这样点击前面的文字也会选中该input输入框，相当于用label包起来了</span><br><span class="line">&gt; 表单中也有一些非input的标签，可以实现input无法实现的功能</span><br><span class="line">    &gt; select标签（下拉框，要写name值，每个选项就是一个option标签，其中可以使用optgroup进行选项分组）</span><br><span class="line">    &gt; textarea标签（多行输入框，可设置宽高，可拉伸，可plactholder预设文本）</span><br><span class="line">&gt; video标签（在页面中添加视频，width设置宽度，controls加入后可控制，poster未播放前的占位图片，加入loop可循环播放，加入preload可预加载，就如muted自动静音）</span><br><span class="line">    &gt; 如果有点浏览器不能识别某种格式的视频文件我们在video标签中可以加入多个source文件来放视频文件，第一个不行就下一个，以此类推</span><br><span class="line">&gt; audio标签（网页插入音频，同理，加入controls即可控制音频）</span><br><span class="line">&gt; &amp;nbsp;空格  &amp;lt小于号  &amp;gt大于号  &amp;copy版权符号</span><br></pre></td></tr></table></figure>
<h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 继承性：给父元素设置一些属性，子元素也可以使用</span><br><span class="line">    &gt; 只有以color,font-,text-,line开头的属性才可以继承</span><br><span class="line">    &gt; CSS中不仅儿子可以继承，后代都可以继承</span><br><span class="line">&gt; 层叠性：CSS处理冲突的一种能力，当同一元素的同一属性设置了不同的属性值</span><br><span class="line">&gt; 优先级：!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br></pre></td></tr></table></figure>
<h2 id="CSS元素的显示模式"><a href="#CSS元素的显示模式" class="headerlink" title="CSS元素的显示模式"></a>CSS元素的显示模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在CSS中标签分为两类：块级元素（p,div,h,ul,ol,dl,li,dt,dd）和行内元素（span,em,strong,del）</span><br><span class="line">&gt; 块级元素：如果没有设置宽度，那么默认和父元素一样宽，如果设置了宽高，则按照设置的显示</span><br><span class="line">&gt; 行内元素：不可以设置宽高，和内容一样宽</span><br><span class="line">&gt; 行内块级元素：为了让元素可以不独占一行又能设置宽度和高度，例如：img标签</span><br><span class="line">&gt; display属性可以进行显示模式的转换</span><br><span class="line">    &gt; diaplay:block; 转换为块级元素</span><br><span class="line">    &gt; diaplay:inline;  转换为行内元素</span><br><span class="line">    &gt; diaplay:inline-block;  转换为行内块元素，工作中前面那个圆的序号可以用span转为inline-block</span><br></pre></td></tr></table></figure>
<h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 背景颜色：background-color</span><br><span class="line">&gt; 背景图片：background-image:url();</span><br><span class="line">    &gt; 如果图片的大小没有父元素大，就会自动在水平和垂直方向平铺和填充</span><br><span class="line">&gt; 背景平铺：background-repeat:repeat-x&#x2F;repeat-y&#x2F;no-repeat，可以使用背景图片的平铺来降低图片的大小，来提升网页的访问速度</span><br><span class="line">&gt; 背景定位：background-position:100px 100px;可以将背景图片相对于父元素进行定位</span><br><span class="line">&gt; 实现图片不随着滚动条而改变：background-attachment:fixed;</span><br></pre></td></tr></table></figure>
<h2 id="网页的布局方式"><a href="#网页的布局方式" class="headerlink" title="网页的布局方式"></a>网页的布局方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; 网页的布局方式就是指浏览器如何对网页中的元素进行排版的</span><br><span class="line">&gt; 文档流排版：浏览器默认是按照文档流的排版方式的，在标准流中有两种排版方式，一种是垂直排版（元素为块级元素），一种是水平排版（元素为行内元素&#x2F;行内块元素）</span><br><span class="line">&gt; 浮动流排版：是一种半脱离文档流的排版方式，浮动流只有一种排版方式就是水平排版，只能设置某个元素左对齐或右对齐</span><br><span class="line">    &gt; 在浮动中不区分inline&#x2F;block&#x2F;inline-block的，这些都可以水平排版</span><br><span class="line">    &gt; 浮动中inline&#x2F;block&#x2F;inline-block都可以设置宽高</span><br><span class="line">    &gt; 综上所述，浮动流中的元素和文档流中的行内块级元素很像</span><br><span class="line">&gt; 元素脱离文档流：当一个元素浮动之后，看上去就像是从文档流中删除了</span><br><span class="line">    &gt; 会出现什么情况？当前一个元素浮动而后一个元素没有浮动，那么前面元素就会盖住后面的元素</span><br><span class="line">&gt; 浮动元素的布局规则：</span><br><span class="line">    &gt; 各找各的，然后按前后顺序排列</span><br><span class="line">    &gt; 文字环绕</span><br><span class="line">&gt; 在文档流中内容高度可以撑起父元素的高度，而浮动的元素是不可以撑起父元素高度的，就是高度塌陷问题</span><br><span class="line">&gt; float是个不错的布局方法，但是使用时也会带来一些问题，如上所提到的，重叠问题，高度塌陷问题等，如果要解决如上问题的话就要清除浮动，方法有以下几种</span><br><span class="line">    &gt; 给父元素加固定的高度，显然不推荐</span><br><span class="line">    &gt; 使用clearfix来解决，推荐</span><br><span class="line">    &gt; 给父元素加上overflow:hidden，推荐</span><br></pre></td></tr></table></figure>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 绝对定位 absolute</span><br><span class="line">&gt; 相对定位 relative</span><br><span class="line">&gt; 固定定位 fixed</span><br><span class="line">&gt; 粘滞定位 sticky</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/01/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">项目中遇到的问题'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-01 14:02:08 / Modified: 14:02:27" itemprop="dateCreated datePublished" datetime="2020-11-01T14:02:08+08:00">2020-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><h2 id="ios-键盘遮挡问题"><a href="#ios-键盘遮挡问题" class="headerlink" title="ios 键盘遮挡问题"></a>ios 键盘遮挡问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scrollIntoView(alignWithTop): 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素</span><br><span class="line">alignWithTop &#x3D; true  或 空   窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐  （元素向上滚动）</span><br><span class="line">alignWithTop &#x3D; false  调用元素会尽可能全部出现在视口中，可能的话，调用元素的底部会与视口顶部平齐，不过顶部不一定平齐。（元素不会滚动）</span><br><span class="line">常见浏览器：IE、Chrome、Firefox、Safari和Opera。 都支持</span><br><span class="line">	let _this &#x3D; this</span><br><span class="line">	setTimeOut(function()&#123;  &#x2F;&#x2F;每100毫秒 滚动1次</span><br><span class="line">		_this.scrollIntoView(true)</span><br><span class="line">	&#125;,100)</span><br><span class="line">面试的时候 要说一下</span><br><span class="line">当input 得到焦点的时候 出发方法，方法作用 从新计算 元素到顶部的距离，元素向上移动的距离&#x3D;软键盘的高度</span><br><span class="line">ios手机型号太多，滚动数值需要多次获取</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="IE9中，-请求服务器数据并用v-for渲染option标签出现只显示第一个字的问题"><a href="#IE9中，-请求服务器数据并用v-for渲染option标签出现只显示第一个字的问题" class="headerlink" title="IE9中， 请求服务器数据并用v-for渲染option标签出现只显示第一个字的问题  *****"></a>IE9中， 请求服务器数据并用v-for渲染option标签出现只显示第一个字的问题  *****</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#123;name:&quot;张三张三张三张三张三张三&quot;,sex:&quot;man&quot;&#125;</span><br><span class="line">&#125; </span><br><span class="line">	&lt;select v-for&#x3D;&quot;&quot;&gt;</span><br><span class="line">		&lt;option&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;option&gt;  &#x3D;&#x3D;&#x3D;&gt; 张</span><br><span class="line">	&lt;&#x2F;select&gt;</span><br><span class="line">	</span><br><span class="line"> 解决： 重绘页面的select 输入框</span><br><span class="line"></span><br><span class="line">	forceRedrawSelect: function (useNextTick) &#123;</span><br><span class="line">	    useNextTick &#x3D; useNextTick !&#x3D;&#x3D; false;</span><br><span class="line">	    if (!browser.isIE)</span><br><span class="line">	        return;</span><br><span class="line">	    var _this &#x3D; this;</span><br><span class="line">	    var redraw &#x3D; function () &#123;</span><br><span class="line">	        var $select &#x3D; _this.$(&quot;select&quot;); &#x2F;&#x2F;选中select</span><br><span class="line">	        &#x2F;&#x2F;移除宽度的样式 </span><br><span class="line">	        $select.css(&#39;width&#39;, 0); </span><br><span class="line">	        $select.css(&#39;width&#39;, &#39;&#39;); </span><br><span class="line">	        &#x2F;&#x2F;单独设定样式</span><br><span class="line">			$select.css(&#39;width&#39;, &#39;300px&#39;);</span><br><span class="line">	    &#125;;</span><br><span class="line">	    if(useNextTick)</span><br><span class="line">	        this.$nextTick(redraw);</span><br><span class="line">	    else</span><br><span class="line">	        redraw()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue自定义指令判断时机问题"><a href="#vue自定义指令判断时机问题" class="headerlink" title="vue自定义指令判断时机问题"></a>vue自定义指令判断时机问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误写法 ，不能通过innerHTML获取</span><br><span class="line">&#39;null&#39; (el) &#123;</span><br><span class="line">    if (el.innerHTML &#x3D;&#x3D;&#x3D; &#39;&#39; || el.innerHTML &#x3D;&#x3D;&#x3D; &#39;--&#39;) &#123;</span><br><span class="line">      addClass(el, &#39;null-handler&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      removeClass(el, &#39;null-handler&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 正确写法 ，直接传值</span><br><span class="line">&#39;null&#39; (el, &#123; value, oldValue &#125;) &#123;</span><br><span class="line">  if (oldValue &#x3D;&#x3D;&#x3D; value) return &#x2F;&#x2F;终止程序</span><br><span class="line">	  if (value &#x3D;&#x3D;&#x3D; &#39;&#39; || value &#x3D;&#x3D;&#x3D; &#39;--&#39;) &#123;</span><br><span class="line">	    addClass(el, &#39;null-handler&#39;)</span><br><span class="line">	  &#125; else &#123;</span><br><span class="line">	    removeClass(el, &#39;null-handler&#39;)</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="mounted钩子函数中请求数据导致页面闪屏问题"><a href="#mounted钩子函数中请求数据导致页面闪屏问题" class="headerlink" title="mounted钩子函数中请求数据导致页面闪屏问题 ****"></a>mounted钩子函数中请求数据导致页面闪屏问题 ****</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是加载时机问题，放在created里会比mounted触发早一点，</span><br><span class="line">如果在页面挂载完之前请求完成的话就不会看到闪屏了</span><br></pre></td></tr></table></figure>

<h2 id="用forEach遍历NodeList，ie报错“nodelist为对象，不支持forEach属性"><a href="#用forEach遍历NodeList，ie报错“nodelist为对象，不支持forEach属性" class="headerlink" title="用forEach遍历NodeList，ie报错“nodelist为对象，不支持forEach属性"></a>用forEach遍历NodeList，ie报错“nodelist为对象，不支持forEach属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; es6写法</span><br><span class="line">let nodeList &#x3D; [...this.$el.querySelectorAll(&#39;[id^&#x3D;productItem]&#39;)] &#x2F;&#x2F;对象转化成集合</span><br><span class="line">&#x2F;&#x2F; es5写法</span><br><span class="line">let nodeList &#x3D; Array.prototype.slice.call(this.$el.querySelectorAll(&#39;[id^&#x3D;productItem]&#39;))</span><br></pre></td></tr></table></figure>


<h2 id="数据接口：-postman可以收到数据，axios收不到-这是为什么？？？？"><a href="#数据接口：-postman可以收到数据，axios收不到-这是为什么？？？？" class="headerlink" title="数据接口： postman可以收到数据，axios收不到 这是为什么？？？？ **"></a>数据接口： postman可以收到数据，axios收不到 这是为什么？？？？ <strong>**</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.post 与 传参格式有关系：</span><br><span class="line">	params：&#123;参数名称:参数值&#125;</span><br><span class="line">2.postman</span><br><span class="line">	header : content-type: applicaton&#x2F;form-data</span><br><span class="line">  axios  默认 json提交，不是表单数据</span><br><span class="line">  	header : content-tye:application&#x2F;x-www-from-urlencode</span><br><span class="line">  	axios.defaults.header.post[&quot;content-type&quot;]  &#x3D; &quot;content-tye:application&#x2F;x-www-from-urlencode&quot;</span><br><span class="line">	axios.create(&#123;</span><br><span class="line">		baseUrl:</span><br><span class="line">		timeOut:</span><br><span class="line">		header:&#123;</span><br><span class="line">			&quot;content-type&quot;:&quot;content-tye:application&#x2F;x-www-from-urlencode&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">3.如果设置成功，还是接受不到---》后台问题</span><br></pre></td></tr></table></figure>

<h2 id="兼容高版本的浏览器-，新api语法如何使用"><a href="#兼容高版本的浏览器-，新api语法如何使用" class="headerlink" title="兼容高版本的浏览器 ，新api语法如何使用"></a>兼容高版本的浏览器 ，新api语法如何使用</h2><p>在项目中，常遇到有些新增api不能正常转化js语法，<br>babel 转换新的 Javascript 句法，而不转换新的 Api ，比如es6中 Generator、Set、Symbol、Promise 等全局对象，为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁） 的技术</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/Node-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/Node-js/" class="post-title-link" itemprop="url">Node.js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 19:05:42 / Modified: 19:07:03" itemprop="dateCreated datePublished" datetime="2020-10-31T19:05:42+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.命令行窗口&#x2F;CMD窗口&#x2F;终端&#x2F;shell</span><br><span class="line">        &gt; 常用的指令：</span><br><span class="line">                   dir - 列出当前文件夹的所有文件</span><br><span class="line">                   cd 目录名 - 进入到指定的目录 tab键位可自动填充</span><br><span class="line">                   md 目录名 - 创建一个文件夹</span><br><span class="line">                   rd 目录名 - 删除一个文件夹</span><br><span class="line">        &gt; 目录</span><br><span class="line">             每一个目录中都有下面的两个东西</span><br><span class="line">             .  表示当前目录</span><br><span class="line">             ..  表示上一级目录</span><br><span class="line">        &gt; 环境变量(window系统中的变量)</span><br><span class="line"></span><br><span class="line">            &gt; 一般只是修改用户变量，不改系统变量；</span><br><span class="line"></span><br><span class="line">            &gt; path，后面跟了一堆的路径，我们如果将一个文件的路径放置在这些路径后面，</span><br><span class="line">               用;隔开，那么我们在任何文件中都可以访问这个路径的文件；</span><br><span class="line"></span><br><span class="line">            &gt; 当我们在命令行窗口打开一个文件，或者调用一个程序时，系统会首先在当前</span><br><span class="line">               目录下寻找文件或者程序，如果找到了则直接打开；如果没有找到则会依次到</span><br><span class="line">               环境变量path后面的路径中寻找，直到找到为止，没找到则报错；</span><br><span class="line"></span><br><span class="line">            &gt; 所以我们可以将一些我们经常访问的程序和文件路径添加到path，这样我们就可</span><br><span class="line">              以在任意位置来访问这些文件和程序；</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- </span><br><span class="line">    2，进程和线程</span><br><span class="line"></span><br><span class="line">         &gt; 进程(提供环境的)</span><br><span class="line"></span><br><span class="line">              -进程负责为程序的运行提供必备的环境；</span><br><span class="line">              -进程就相当于工厂中的车间；</span><br><span class="line"></span><br><span class="line">         &gt; 线程(干活的)</span><br><span class="line"></span><br><span class="line">              -线程是计算机中最小的计量单位，线程负责执行进程中的程序；</span><br><span class="line">              -线程相当于工厂中的工人；</span><br><span class="line"></span><br><span class="line">         &gt; 单线程</span><br><span class="line">              </span><br><span class="line">              -可以理解为单个人干一项工作；</span><br><span class="line">              -JS是单线程的，因为有可能出现混乱；</span><br><span class="line"></span><br><span class="line">         &gt; 多线程</span><br><span class="line"></span><br><span class="line">              -可以理解为多个人干同一项工作；</span><br><span class="line">              -主流的语言都是多线程的；</span><br></pre></td></tr></table></figure>

<h2 id="Node基础"><a href="#Node基础" class="headerlink" title="Node基础"></a>Node基础</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.Node.js简介</span><br><span class="line">        &gt; Node.js是一个能够在服务端运行JS的开放源代码、跨平台的JS运行环境；</span><br><span class="line">        &gt; 非常重要、非常厉害的一点就是把战场从浏览器转移到了服务器端，可以让我们直接和windows系统进行交互</span><br><span class="line">          这就和C、C++、Java等一样了，让前端变得被人重视了起来；</span><br><span class="line">        &gt; 常用6.0版本；</span><br><span class="line">      </span><br><span class="line">    2.Node</span><br><span class="line">        &gt; Node是对ES标准的一个实现，Node也是一个JS引擎；</span><br><span class="line">        &gt; 通过Node可以使JS代码在服务器端运行；</span><br><span class="line">        &gt; Node仅仅对ES标准进行了实现，所以Node中不包含BOM和DOM；</span><br><span class="line">        &gt; Node中可以使用所有的内建对象：</span><br><span class="line">              String Number Boolean Math Date RegExp Function Object Array</span><br><span class="line">              但是BOM和DOM都不可使用</span><br><span class="line">              可以使用console,也可以使用定时器(setTimeout() setInterval());</span><br><span class="line">        &gt; Node可以在后台来编写服务器，Node编写的都是单线程的服务器</span><br><span class="line">        &gt; 传统的服务器都是多线程的；</span><br><span class="line">        &gt; Node的服务器是单线程的，但是在后台有一个I&#x2F;O(指的是服务器与数据库之间的数据交换input&#x2F;output)线程池;</span><br><span class="line">        &gt; </span><br></pre></td></tr></table></figure>

<h2 id="commons规范"><a href="#commons规范" class="headerlink" title="commons规范"></a>commons规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    JS (ECMAScript) 标准的缺陷</span><br><span class="line">       &gt; 没有模块系统；</span><br><span class="line">            模块化(一个项目的代码分为多个模块，可以复用，效率较高，不同的模块负责不同的功能);</span><br><span class="line">                  (在Node中，一个JS文件就是一个模块)；</span><br><span class="line">       &gt; 标准库较少；</span><br><span class="line">       &gt; 没有标准接口；</span><br><span class="line">       &gt; 缺乏管理系统；</span><br><span class="line"></span><br><span class="line">    CommonJS规范</span><br><span class="line">       &gt; 这个的提出，主要是为了弥补当前JavaScript没有模块化标准的缺陷；</span><br><span class="line">       &gt; 它为JS制定了一个美好的愿景，希望JS可以在任何地方运行；</span><br><span class="line">       &gt; 它对模块的定义十分简单：</span><br><span class="line">            -模块引用</span><br><span class="line">                &gt; 在Node中，通过require()函数来引入外部的模块，括号中可以传递一个文件的路径；</span><br><span class="line">                &gt; 使用require()引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块</span><br><span class="line">                  可以使用var md &#x3D; require(&quot;要引入的模块&quot;);这样要使用的话直接：md.变量 即可;</span><br><span class="line">            -模块定义</span><br><span class="line">                &gt; 在Node中，每一个JS文件中的JS代码都是独立运行在一个函数中，而不是全局作用域;</span><br><span class="line">                &gt; 一个模块中的变量和函数在其他的模块中无法访问;</span><br><span class="line">                &gt; 但是如果我们想让外部JS文件访问到，就需要向外部暴露属性或方法;</span><br><span class="line">                &gt; 通过exports向外部暴露变量和方法：exports.变量&#x2F;函数 &#x3D; &quot;值&#x2F;函数体&quot;;</span><br><span class="line">            -模块标识</span><br><span class="line">                &gt; 我们使用require()引入外部模块时，使用的就是模块标识，我们通过模块标识找到指定的模块</span><br><span class="line">                &gt; 模块分为两大类</span><br><span class="line">                     -核心模块</span><br><span class="line">                         &gt; 由Node引擎提供的模块；</span><br><span class="line">                         &gt; 核心模块的标识就是模块的名字,如：var fs &#x3D; reruire(&quot;fs&quot;);</span><br><span class="line">                     -文件模块</span><br><span class="line">                         &gt; 由用户自己创建的模块；</span><br><span class="line">                         &gt; 文件模块的标识就是文件的路径，一般是相对路径，使用.或者..开头；</span><br></pre></td></tr></table></figure>

<h2 id="Node模块"><a href="#Node模块" class="headerlink" title="Node模块"></a>Node模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line"></span><br><span class="line">    Node模块module的相关知识：</span><br><span class="line"></span><br><span class="line">        1.在Node中有一个全局对象 global ,它的作用和 网页中的 window 类似；</span><br><span class="line">             -在全局中创建的变量都会作为global的属性保存；</span><br><span class="line">             -在全局中创建的函数都会作为global的方法保存；</span><br><span class="line"></span><br><span class="line">        2.在Node执行模块中的代码时，它会自动在我们编写的代码顶部添加如下代码：</span><br><span class="line">               function(exports, require, module, _filename, _dirname)&#123;</span><br><span class="line">                在我们编写的代码底部添加：</span><br><span class="line">               &#125;</span><br><span class="line">            这可以理解为Node将我们编写的代码封装成了一个函数，同时传进去了5个实参</span><br><span class="line">                 - exports &gt; 用来将变量或函数暴露到外部，让别的模块也可以访问使用；</span><br><span class="line">                 - require &gt; 函数，用于引入外部的模块；</span><br><span class="line">                 - module &gt; 代表的是当前模块本身；</span><br><span class="line">                          &gt; exports就是module的属性；</span><br><span class="line">                          &gt; 既可以用exports导出，也可以使用module.exports导出；</span><br><span class="line">                 - _filename &gt; 当前模块的完整路径；</span><br><span class="line">                 - _dirname &gt; 当前模块所在文件夹的完整路径；</span><br><span class="line">        3.exports和module.exports两者的区别：</span><br><span class="line">           &gt; 使用exports只能使用.的方式向外暴露内部变量；</span><br><span class="line">                 - exports.xxx &#x3D; xxx;</span><br><span class="line">           &gt; 使用module.exports的方式既可以使用.的方式，也可以直接赋值；</span><br><span class="line">                 - module.exports.xxx &#x3D; xxx;</span><br><span class="line">                 - module.exports &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                 </span><br><span class="line">                 - 当使用exports &#x3D; &#123;</span><br><span class="line">                      name:jack;</span><br><span class="line">                      age:23;</span><br><span class="line">                      sayName:function()&#123;&#125;;</span><br><span class="line">                   &#125;；时，是在修改变量；</span><br><span class="line">                 - 而在使用module.exports &#x3D; &#123;</span><br><span class="line">                      name:jack;</span><br><span class="line">                      age:23;</span><br><span class="line">                      sayName:function()&#123;&#125;;</span><br><span class="line">                   &#125;; 时，是在修改module的属性；</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    包(package)</span><br><span class="line">      &gt; CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一个完整的工具；</span><br><span class="line">      &gt; CommonJS的包规范由两部分组成：</span><br><span class="line">          - 包结构：用于组织包中的各种文件；</span><br><span class="line">               包实际上就是一个压缩文件，解压以后还原为目录，应该包含：</span><br><span class="line">               &gt; package.json 描述文件(必须的);</span><br><span class="line">               &gt; bin 可执行二进制文件</span><br><span class="line">               &gt; lib js代码</span><br><span class="line">               &gt; doc 文档</span><br><span class="line">               &gt; text 单元测试</span><br><span class="line">          - 包描述文件：描述包的相关信息，以供外部读取分析；</span><br><span class="line">               &gt; 用于描述非代码的相关信息package.json,位于包的根目录下</span><br><span class="line">               &gt; package.json中的一些字段：name,description,version,</span><br><span class="line">                 keywords,maintainers,contributors,bugs,licences,</span><br><span class="line">                 os,cpu,engine,author,bin,main,devDependencies...</span><br><span class="line">               &gt; json中不可以写注释</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    NPM(Node Package Manager)</span><br><span class="line">      &gt; CommonJS包规范是理论，NPM是其中一种实践；</span><br><span class="line">      &gt; 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖(有的包需要别的包)等，</span><br><span class="line">        借助NPM，Node与第三方模块之间形成了一个很好的生态系统；</span><br><span class="line">      &gt; 甚至有的时候，大家下载Node其实是想用NPM</span><br><span class="line">      &gt; 使用方法：</span><br><span class="line">            1.首先npm是Node中自带的，直接在cmd中输入npm即可以查看是否安装成功</span><br><span class="line">            2.可以使用npm search 包的名字  来查询npm中的相关的包</span><br><span class="line">            3.使用npm install 包的名字  来下载包到本地(注意：如果想让包下载到</span><br><span class="line">              指定文件夹，直接在指定文件夹目录下的路径框中输入cmd回车，cmd可以</span><br><span class="line">              直接跳转到指定文件夹，再用npm install即可下载);       </span><br><span class="line">            4.在cmd中键入：cmd init 可以默认产生一个package.json文件</span><br><span class="line">      &gt; npm的命令：</span><br><span class="line">            npm -v 查看npm的版本；</span><br><span class="line">            npm version 查看所有模块的版本；</span><br><span class="line">            npm search 包名 搜索包</span><br><span class="line">            npm indtall&#x2F;i 包名 安装包</span><br><span class="line">            npm remove&#x2F;r 包名 删除包</span><br><span class="line">            npm install 包名 --save 安装包并添加到依赖中****</span><br><span class="line">            npm install 下载当前项目所依赖的包</span><br><span class="line">            以后从github上下载下来一个项目，不要直接运行，先npm install以下，下载所有依赖的包</span><br><span class="line">            npm install 包名 -g 全局安装包(一般都是一些工具)</span><br><span class="line"></span><br><span class="line">      &gt; 由于npm的服务器在美国，网速有限制，所以国内的淘宝做了一个镜像服务器，我们需要先进行配置</span><br><span class="line">        这样就可以使用国内的服务器了。在命令行窗口中输入：</span><br><span class="line">        npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">        这样的好处是如果要使用国内的就用cnpm代替npm，要用国外的就继续使用npm；</span><br><span class="line"></span><br><span class="line">      &gt; 通过npm 下载的包都放在node_module 文件夹中，我们通过npm下载的包，直接通过包名引入即可；</span><br><span class="line">            var math &#x3D; require(&quot;math&quot;);</span><br><span class="line">            var express &#x3D; require(&quot;express&quot;);</span><br><span class="line"></span><br><span class="line">      &gt; node在使用模块名字来引入模块时，它会首先在当前目录的node_module目录中寻找是否含有该模块</span><br><span class="line">        如果有则直接使用，如果没有，它会去上一级的node_module目录中寻找，如果有则直接使用，如果</span><br><span class="line">        没有，则继续去上一级目录中寻找，直到找到为止；直到找到磁盘的根目录，如果还是没有则报错；</span><br><span class="line"></span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="buffer缓冲"><a href="#buffer缓冲" class="headerlink" title="buffer缓冲"></a>buffer缓冲</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    buffer(缓冲区)</span><br><span class="line">       &gt; buffer的结构和数组很像，操作方法也和数组类似；</span><br><span class="line">       &gt; 数据中不可以存储二进制文件(如：图片、音乐、视频等)，buffer就是用来存储二进制数据的；</span><br><span class="line">       &gt; Buffer不需要引用模块，直接使用即可；</span><br><span class="line">       &gt; 从结构上看，Buffer非常像一个数组，它的元素为16进制的两位数；</span><br><span class="line">                   8位 &#x3D; 1字节，8bit &#x3D; 1byte ,最小单位就是字节;</span><br><span class="line">       &gt; 实际上一个元素就表示内存中的一个字节；</span><br><span class="line">       &gt; Buffer中的内存不是通过js分配的，而是通过底层的C++申请的；</span><br><span class="line">       &gt; 我们可以通过Buffer来创建内存中的空间；</span><br><span class="line">       &gt; buffer 构造函数都是不推荐使用的；</span><br><span class="line">       &gt; 创建一个10个字节的Buffer： var buf &#x3D; Buffer.alloc(10);  &#x2F;&#x2F;&lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span><br><span class="line">       &gt; 通过索引来操作buf中的元素： buf[0] &#x3D; 88;   &#x2F;&#x2F;&lt;Buffer 58 00 00 00 00 00 00 00 00 00&gt;加进去变为16进制的</span><br><span class="line">       &gt; buffer的大小一旦确定，则不能修改，无法添加和删除元素，buffer是对底层内存的直接操作；</span><br><span class="line">       &gt; 只要数字在控制台或者页面中输出，则一定是10进制；</span><br><span class="line">       &gt; allocUnsafe(size)也是创建一个指定大小的buffer，但是buffer中可能含有敏感数据(他不会清空</span><br><span class="line">         内存，而这个内存里可能含有上一个使用这一块内存的数据)，但是性能好一些，因为没有清空数据；</span><br><span class="line">       &gt; Buffer.from(str); 将一个字符串转换为buffer;</span><br><span class="line">       &gt; 为什么是缓冲区？我们接受用户发来的请求(二进制数字)，先将其存在buffer中；我们给用户发送请求，也是先存在buffer；</span><br><span class="line">       &gt; toString()方法可以将缓冲区中的数据转换为字符串：</span><br><span class="line">                var buf &#x3D; Buffer.from(&quot;我是一段文本数据&quot;);</span><br><span class="line">                console.log(buf.toString());&#x2F;&#x2F;我是一段文本数据</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="文件系统fs"><a href="#文件系统fs" class="headerlink" title="文件系统fs"></a>文件系统fs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    fs(文件系统File System)</span><br><span class="line">       &gt; 文件系统简单来说就是通过Node来操作系统中的文件增删改查；</span><br><span class="line">       &gt; 在Node中，与文件系统的交互是非常重要的，服务器的本质就是将本地的</span><br><span class="line">         文件发送给远程的客户端；</span><br><span class="line">       &gt; Node通过fs模块来和文件系统进行交互；</span><br><span class="line">       &gt; fs模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互；</span><br><span class="line">       &gt; 要使用fs模块，首先要对其进行加载：const fs &#x3D; requires(&quot;fs&quot;);</span><br><span class="line">       &gt; fs模块中所有的操作都有两种形式可供选择：同步(带有Sync)和异步(都有callback回调函数)；</span><br><span class="line">       &gt; 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码；</span><br><span class="line">       &gt; 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回；</span><br><span class="line"></span><br><span class="line">       &gt; 同步文件的写入</span><br><span class="line">            1. 打开文件</span><br><span class="line">                    fs.openSync(path, flags[, mode]);</span><br><span class="line">                        -path 要打开文件的路径；</span><br><span class="line">                        -flags 打开文件要做的操作的类型：r只读的  w可写的；</span><br><span class="line">                        -mode 设置文件的操作权限，一般不传省略； </span><br><span class="line">                        如：fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);</span><br><span class="line">                        该方法有返回值，返回一个文件的描述符(一个数字)作为结果，我们可以</span><br><span class="line">                        根据该描述符来对文件进行各种操作；</span><br><span class="line">            2.向文件中写入内容</span><br><span class="line">                    fs.writeSync(fd, string[, position[, encoding]]);</span><br><span class="line">                        -fd 文件的描述符，选择我们要写入的文件的描述符；</span><br><span class="line">                        -string 我们要写入的内容；</span><br><span class="line">                        -position 写入的其实位置；</span><br><span class="line">                        -encoding 写入的编码，默认utf-8；</span><br><span class="line">                        如：fs.writeSync(fd, &quot;今天天气真不错&quot;);</span><br><span class="line">            3.保存并关闭文件</span><br><span class="line">                    fs.closeSync(fd);</span><br><span class="line">                        -fd 要关闭文件的描述符；</span><br><span class="line">                        如：fs.closeSync(fd);</span><br><span class="line"></span><br><span class="line">       &gt; 异步文件的写入</span><br><span class="line">            1.打开文件</span><br><span class="line">                    fs.open(path, flags[, mode], callback);</span><br><span class="line">                    -callback 必须传递一个函数</span><br><span class="line">                    -异步调用的方法，结果都是通过回调函数的参数返回的</span><br><span class="line">                    -回调函数有两个参数</span><br><span class="line">                          参数一：err  错误对象，如果没有错误，则为null</span><br><span class="line">                          参数二：fd  文件的描述符</span><br><span class="line">                    如callback中传递的回调函数为：</span><br><span class="line">                          function(err, fd)&#123;</span><br><span class="line">                            if(!err)&#123;</span><br><span class="line">                              XXXX;</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                              XXXX</span><br><span class="line">                            &#125;</span><br><span class="line">                          &#125;;</span><br><span class="line">                    这样可以对出错的文件进行操作，比较强大；</span><br><span class="line">            2.异步写入文件</span><br><span class="line">                    fs.write(fd, string[, position[, encoding]],callback);</span><br><span class="line">                    -当异步调用中的回调函数执行时，代表程序已经执行完成了，这就是异步操作的优点；</span><br><span class="line">                    -注意，写入操作要写在上一步打开文件的操作函数中：</span><br><span class="line">                                if(!err)&#123;</span><br><span class="line">                                   fs.write(fd, string[, position[, encoding]],function(err)&#123;</span><br><span class="line">                                     if(!err)&#123;</span><br><span class="line">                                      XXX;</span><br><span class="line">                                     &#125;else&#123;</span><br><span class="line">                                      XXX;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                   &#125;);</span><br><span class="line">                                  &#125;else&#123;</span><br><span class="line">                                   XXXX；</span><br><span class="line">                                  &#125;</span><br><span class="line">            3.关闭文件</span><br><span class="line">                    fs.closeSync(fd, callback);</span><br><span class="line">                    -注意，关闭文件的操作要写在上一个操作的if中；</span><br><span class="line">            -总结一下：异步的操作都需要写一个回调函数，接下来的操作都是在这个回调函数中进行的，</span><br><span class="line">                      这个回调函数中一般都是由一个if判断的，如果if判断没有错误，则直接将接下</span><br><span class="line">                      来的操作写在if中即可；</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- </span><br><span class="line">      简单文件写入</span><br><span class="line">      fs.writefile(file, data[, options], callback);</span><br><span class="line">      fs.writefileSync(file, data[, options]);</span><br><span class="line">            -file 要操作文件的路径，可以绝对路径也可以相对路径，注意用两个&#x2F;&#x2F;，由于转义字符的原因；</span><br><span class="line">            -data 要写入的数据</span><br><span class="line">            -options 选项，可以对写入进行一些设置，一般都是一个对象&#123;encoding:,mode:,flag:r只读w可写a追加&#125;一般省略</span><br><span class="line">            -callback 当写入完成以后执行的函数</span><br><span class="line">      </span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- </span><br><span class="line">      流式文件写入(针对文件较大时使用)</span><br><span class="line">         &gt; 以上同步异步和简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出；</span><br><span class="line">         &gt; 流式文件的写入可以理解为：把要写的文件通一个水管，慢慢的一点点的流入要写入的文件；</span><br><span class="line">         &gt; 操作步骤：</span><br><span class="line">                   1.创建一个可写流：fs.creatWriteSteam(path[, options]),path文件路径，options同上省略</span><br><span class="line">                   2.通过ws向文件中输出内容：ws.write(&quot;通过可写流写入文件的内容&quot;)，可重复写入，分多次写入；                 </span><br><span class="line">                   3.可以通过监听流的open和close事件来监听流的打开和关闭：</span><br><span class="line">                         ws.once(&quot;open&quot;,function()&#123;~~~&#125;;);流打开时触发，用once而不用on是因为只使用一次</span><br><span class="line">                         ws.once(&quot;close&quot;, function()&#123;~~~&#125;);流关闭时触发，当出现代码ws.end()时执行</span><br><span class="line">   --&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- </span><br><span class="line">      同步文件读取    将write改为read即可</span><br><span class="line">      异步文件读取</span><br><span class="line">      简单文件读取</span><br><span class="line">            fs.readFile(path[, options], callback)</span><br><span class="line">            fs.readFileSync(path[, options])</span><br><span class="line">            callback回调函数由两个参数err和data，其中data返回一个buffer，可以用来复制</span><br><span class="line">      流式文件读取</span><br><span class="line">            流式文件读取也适用于一些较大的文件，可以分多次将文件读取到内存中</span><br><span class="line">            1.创建一个可读流：fs.createReadStream(&quot;路径&quot;);</span><br><span class="line">            2.监听流的开启和关闭，同上</span><br><span class="line">            3.如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动读取数据</span><br><span class="line">                rs.on(&quot;data&quot;, function(data)&#123;~~~&#125;);</span><br><span class="line">              其中的data 就是读取到的数据，文件较大的话分为多个Buffer</span><br><span class="line">            4.如果想把读取的内容想写入一个可写流里</span><br><span class="line">                    var ws &#x3D; fs.createWriteStream(&quot;要写入的文件夹&quot;)；&#x2F;&#x2F;创建一个可写流</span><br><span class="line">                    ws.write(data);&#x2F;&#x2F;写入</span><br><span class="line">                    ws.end();&#x2F;&#x2F;关闭可写流</span><br><span class="line"></span><br><span class="line">            简单方法：将一个可读流文件写入一个可写流里面</span><br><span class="line">                         rs.pipe(ws);&#x2F;&#x2F;在rs和ws之间加上一个管道，可读流直接写入到可写流中；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fs其他方法"><a href="#fs其他方法" class="headerlink" title="fs其他方法"></a>fs其他方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    fs其他方法</span><br><span class="line">        &gt; 验证路径是否存在</span><br><span class="line">           fs.existsSync(path);</span><br><span class="line">        &gt; 获取文件信息</span><br><span class="line">           fs.stat(path, callback)</span><br><span class="line">              它会返回一个对象，这个对象中保存了当前对象状态的相关信息</span><br><span class="line">              callback中有两个参数，err和stat；</span><br><span class="line">           fs.statSync(path)</span><br><span class="line">        &gt; 删除文件</span><br><span class="line">           fs.unlink(path, callback)</span><br><span class="line">           fs.unlinkSy(path)</span><br><span class="line">        &gt; 列出文件(读取一个目录的目录结构)</span><br><span class="line">           fs.readdir(path[, options], callback)</span><br><span class="line">               callback中两个参数，err和files，files是一个字符串数组，包含所有文件</span><br><span class="line">           fs.readdirSync(path[, options])</span><br><span class="line">        &gt; 截断文件(将文件修改为指定的大小)</span><br><span class="line">           fs.truncate(path, len, callback)</span><br><span class="line">           fs.truncateSync(path, len)</span><br><span class="line">        &gt; 建立目录(创建一个文件夹)</span><br><span class="line">           fs.mkdir(path[, mode], callback)</span><br><span class="line">           fs.mkdirSync(path[, mode])</span><br><span class="line">        &gt; 删除目录</span><br><span class="line">           fs.rmdir(path,callback)</span><br><span class="line">           fs.rmdirSync(path)</span><br><span class="line">        &gt; 重命名文件或目录(可以实现剪切的功能)</span><br><span class="line">           fs.rename(oldpath, newPath, callback)</span><br><span class="line">           fs.renameSync(oldPath, newPath)</span><br><span class="line">        &gt; 监视文件的更改</span><br><span class="line">           fs.watchFile(filename[, options], listener)</span><br><span class="line">                 filename  要监视的文件的名字</span><br><span class="line">                 options  配置选项，传一个对象，对象里添加属性，如：&#123;interval:1000&#125;可以设置检查的时间；</span><br><span class="line">                 listener  回调函数，当文件发生变化时执行</span><br><span class="line">                     这个回调函数中有两个参数</span><br><span class="line">                           curr  当前文件的状态</span><br><span class="line">                           prev  修改前文件的状态</span><br><span class="line">                           这两个对象都是stats对象，可以使用curr.size就可以得到文件大小的变化</span><br><span class="line"></span><br><span class="line"> --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/git/" class="post-title-link" itemprop="url">git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 19:05:27 / Modified: 19:06:41" itemprop="dateCreated datePublished" datetime="2020-10-31T19:05:27+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>git是为了管理linux系统下代码的工具，后来延申出来到各个系统都可使用</p>
</blockquote>
<h2 id="Git与svn对比"><a href="#Git与svn对比" class="headerlink" title="Git与svn对比"></a>Git与svn对比</h2><blockquote>
<p>svn</p>
</blockquote>
<ul>
<li>这是一个集中式的代码管理工具，首先需要一台svn服务器，每一个开发电脑上需要装上一个svn的客户端，可以直接将代码提交到svn服务器上，想下载代码，可以直接从svn服务器上下载到本地，代码由svn服务器统一管理</li>
</ul>
<blockquote>
<p>Git</p>
</blockquote>
<ul>
<li>分布式的版本控制系统，没有中央服务器，每个人的电脑上都有一个完整的版本库，这样工作的时候就不需要联网了，但是如何多人协作呢？如果需要交换代码就需要一个远程仓库，也叫做共享版本库；如鼓果只是单人进行开发就不需要远程仓库，自己形成要给闭环；</li>
</ul>
<h2 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h2><ul>
<li>从远程仓库克隆Git资源作为本地仓库；</li>
<li>从本地仓库中checkout代码，然后进行代码修改；</li>
<li>在提交前先将代码提交到暂存区；</li>
<li>提交修改，提交到本地仓库，本地仓库中保存修改的各个历史版本；</li>
<li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库；</li>
</ul>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ul>
<li><p>tortoiseGit安装</p>
</li>
<li><p>安装完成之后，首先需要创建一个版本库，也就是本地仓库，三种方法：</p>
<ul>
<li>右键 Git GUI here 创建一个新仓库；</li>
<li>右键 Git Bash Here 打开命令行，输入git init</li>
<li>右键，用乌龟创建tortoiseGit创建；</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： .git文件夹就是本地版本库包含.git 的这个目录叫做工作目录如果想向本地仓库.git添加一个文件的话，这个文件必须在工作目录下</p>
</blockquote>
<h2 id="如何向本地仓库中添加文件"><a href="#如何向本地仓库中添加文件" class="headerlink" title="如何向本地仓库中添加文件"></a>如何向本地仓库中添加文件</h2><ul>
<li>将工作目录下的文件右键-tortoiseGit-添加</li>
<li>这个时候文件是加入到了暂存区index Stage，文件图标显示一个加号；<blockquote>
<p>工作区和暂存区介绍：工作区(Working Directory)也就是工作目录，上文说过；暂存区：其实也就是版本库里面的一个区域</p>
</blockquote>
</li>
<li>然后再右键-Git(提交)-&gt;master</li>
<li>接着需要写入日志信息，也就是本次对代码进行了何种操作，要写出来；</li>
<li>点击提交，要添加的文件图标上就会显示一个对勾，表示添加成功</li>
</ul>
<h2 id="修改内容并提交"><a href="#修改内容并提交" class="headerlink" title="修改内容并提交"></a>修改内容并提交</h2><ul>
<li>添加成功之后，右键-tortoiseGit-版本库浏览器-就可以看到本地仓库里面的内容了</li>
<li>如果需要修改文件，则直接修改，然后再点一次提交即可，每次都要  写日志信息</li>
</ul>
<h2 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h2><ul>
<li>误删了可以右键-tortoise-还原</li>
<li>右键删除之后，本地仓库中这个文件还是有的，如果要彻底删除这个文件就可以右键点击 git(提交)，就会显示缺失状态的文件，点击提交即可；</li>
<li>如果希望在仓库中删除但是本地保留的话：可以点击&lt;删除并保留本地副本&gt;点击提交，就会在本地保留，仓库中删除；</li>
</ul>
<h2 id="将项目添加到本地仓库"><a href="#将项目添加到本地仓库" class="headerlink" title="将项目添加到本地仓库"></a>将项目添加到本地仓库</h2><ul>
<li>将项目文件夹复制粘贴到工作目录下</li>
<li>添加到暂存区</li>
<li>项目中不需要传进仓库的我们要将其忽略掉，右键-tortoiseGit-删除并添加到 忽略列表-递归忽略-gitignore到文件夹所在目录-保留本地文件 即可；</li>
<li>注意 ：.gitignore文件依然要添加到仓库；</li>
<li>然后回到工作目录下，将整个项目文件夹提交到版本库；</li>
</ul>
<h2 id="用Github创建一个远程仓库"><a href="#用Github创建一个远程仓库" class="headerlink" title="用Github创建一个远程仓库"></a>用Github创建一个远程仓库</h2><ul>
<li>如果一个项目开发需要多个开发人员，需要交换代码，就需要一个远程仓库</li>
<li>创建一个新仓库：填写名称，描述，公开性，不要README文件</li>
</ul>
<h2 id="将代码推送到远程仓库，两种方式"><a href="#将代码推送到远程仓库，两种方式" class="headerlink" title="将代码推送到远程仓库，两种方式"></a>将代码推送到远程仓库，两种方式</h2><blockquote>
<p>SSH:是目前最安全的传输协议，需要生成一对密钥对</p>
</blockquote>
<ul>
<li>首先在工作目录中右键-get bash here-键入’ssh-keygen -t rsa’</li>
<li>一路回车，就会在当前用户目录下的.ssh文件夹中生成一个密钥对</li>
<li>其中没有后缀的就是私钥，公钥需要告诉github服务器</li>
<li>复制公钥，GitHub中点击头像-&gt;setting-&gt;SSH and …-&gt;将其粘贴即可；</li>
<li>这样就可以无需输入用户名和密码就可以直接和服务器进行安全通信</li>
<li>使用对应的命令就可以将本地仓库push到远程仓库了</li>
<li>重新打开一个Git bash here，将对应的代码输入，就推送成功了，刷新即可</li>
<li>也可以使用乌龟tortoiseGit来实现推送，但是我喜欢命令行^0^</li>
</ul>
<blockquote>
<p>HTTPS:</p>
</blockquote>
<ul>
<li>不需要生成密钥对了，但是需要Github的用户名和密码</li>
<li>其余的和SSH一样</li>
</ul>
<h2 id="克隆远程仓库到本地"><a href="#克隆远程仓库到本地" class="headerlink" title="克隆远程仓库到本地"></a>克隆远程仓库到本地</h2><ul>
<li>找到需要下载的项目，直接点击绿色按钮<clone or download></li>
<li>可以使用两种方式HTTPS和SSH进行下载</li>
<li>命令行窗口打开，键入：git clone 粘贴HTTPS或者SSH路径即可；</li>
</ul>
<h2 id="将修改的文件推送到Github以及冲突的解决"><a href="#将修改的文件推送到Github以及冲突的解决" class="headerlink" title="将修改的文件推送到Github以及冲突的解决"></a>将修改的文件推送到Github以及冲突的解决</h2><ul>
<li>需要使用乌龟，这样推送和拉取很方便，直接右键同步即可；</li>
<li>在这个过程中可能会遇到冲突问题，比如在你修改文件时，别人传进去了自己修改后的，这样你本地的文件就不是最新的，这样推送就会失败，冲突的文件会显示感叹号，我们必须手动修改冲突文件，把远端给我们加上的特殊字符进行删除，将代码合并，然后右键-&gt;解决冲突，然后提交到本地仓库，然后点击推送，就把修改后的推送到了远程，这样就把两个人两次修改的内容都同步到了远程。</li>
</ul>
<h2 id="搭建私有git服务器"><a href="#搭建私有git服务器" class="headerlink" title="搭建私有git服务器"></a>搭建私有git服务器</h2><ul>
<li>有时一些保密的项目不能传到Github上，所以需要搭建一个私有的远程仓库</li>
<li>需要在linux系统中操作</li>
</ul>
<h2 id="分支概念"><a href="#分支概念" class="headerlink" title="分支概念"></a>分支概念</h2><ul>
<li>只要有本地仓库，就会有一个master分支，也就是主分支，master指针指向当前版本；</li>
<li>如果想在现有代码上进行自己的修改，就可以创建一个分支(如dev)，每修改一次就会产生一个版本，每个版本都有dev指针指向；</li>
<li>分支可以有n个，每个分支里面的内容是互不干扰的，同时也可以将不同的分支内容合并到一起，觉得分支不用了，还可以将其删除；</li>
<li>如何创建分支：在仓库中右键-&gt;乌龟-&gt;切换/检出/创建分支-&gt;输入分支名称即可；</li>
<li>分支之间就像是平行时空</li>
</ul>
<h2 id="分支的合并和删除"><a href="#分支的合并和删除" class="headerlink" title="分支的合并和删除"></a>分支的合并和删除</h2><ul>
<li>首先切换到master(最终要哪个分支就切换到哪个分支)</li>
<li>右键-&gt;乌龟-&gt;合并，选择要合并的分支名称即可；</li>
<li>合并过程中会产生冲突，比如对同一个文件两个分支都进行了修改<pre><code>    这时就根据上面所说的解决冲突的方式，手动进行解决，重新提交master即可；</code></pre>
</li>
<li>不用的分支右键-&gt;切换/检出-&gt;右键删除分支即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/Express/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/Express/" class="post-title-link" itemprop="url">Express</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 19:05:16 / Modified: 19:06:27" itemprop="dateCreated datePublished" datetime="2020-10-31T19:05:16+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="express简介"><a href="#express简介" class="headerlink" title="express简介"></a>express简介</h2><blockquote>
<p>Express框架简介</p>
</blockquote>
<ul>
<li>是一个基于Node平台的Web应用开发框架，提供了一系列强大的特性，专门用来创建网站应用的,同时弥补了原生Node.js写起来复杂的缺点如：路由功能的实现，静态资源访问服务功能，接受POST请求参数的代码这都和网站应用本身的业务逻辑没有关系；</li>
<li>使用 npm install express 进行下载</li>
<li>框架为我们提供的特性：<ul>
<li>提供了简洁的路由定义方式</li>
<li>对获取HTTP请求参数进行了简化处理</li>
<li>对模板引擎的支持度较高，方便渲染动态HTML页面</li>
<li>提供了中间件(简单理解为对请求的拦截)机制，有效控制HTTP请求</li>
<li>拥有大量的第三方中间件对功能进行了扩展</li>
</ul>
</li>
</ul>
<h2 id="express创建服务器的方法"><a href="#express创建服务器的方法" class="headerlink" title="express创建服务器的方法"></a>express创建服务器的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在项目中引入express框架</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建网站服务器</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39; , (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;send()方法</span><br><span class="line">    &#x2F;&#x2F; 1.send()方法内部会检测响应内容的类型</span><br><span class="line">    &#x2F;&#x2F; 2.send()方法会自动设置http状态码</span><br><span class="line">    &#x2F;&#x2F; 3.send()方法帮我们自动设置响应的内容类型和编码</span><br><span class="line">    res.send(&#39;Hello. Express&#39;);</span><br><span class="line">    &#x2F;&#x2F; 运行文件就会显示：网站服务器启动成功</span><br><span class="line">    &#x2F;&#x2F; 在网页中输入localhost:3000就可以显示Hello. Express</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;list&#39;, (req , res) &#x3D;&gt; &#123;</span><br><span class="line">    res.send(&#123;name: &#39;张三&#39;, age: 20&#125;);</span><br><span class="line">    &#x2F;&#x2F; 此时访问localhost:3000&#x2F;list,将服务器重新启动，刷新即可看到</span><br><span class="line">    &#x2F;&#x2F; 页面中显示一个JSON对象</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听端口</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&quot;网站服务器启动成功&quot;);</span><br></pre></td></tr></table></figure>


<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<ul>
<li>中间件其实就是Express框架提供的一堆方法，可以接受客户端发来的请求，可以对请求做出响应，专门是用来接受请求处理请求的</li>
<li>对于一个请求，Express允许我们设立多个中间件，这些中间件按照设定的顺序依次对请求进行处理，可以把请求当作一条水流，而中间件就是这条水流中的一个个阀门，可以决定水流是否可以继续向下流动，也可以在当下阀门处对水流进行排污处理，处理完成后再继续向下流动。</li>
<li>给我们带来的好处：可以将一个复杂的请求处理逻辑进行分开处理，也可以再请求到达指定路由前进行一些验证，如查看用户是否登录，登陆了才继续向下进行</li>
<li>中间件由两部分构成，第一部分是由框架提供的，用于接受请求的方法第二部分由开发人员提供的，用于处理请求的方法，如：<ul>
<li>app.get(‘请求路径’,’处理函数’);//接受并处理get请求</li>
<li>app.post(‘请求路径’,’处理函数’);//接受并处理post请求</li>
</ul>
</li>
<li>中间件处理请求时，默认情况是从上到下依次匹配中间件一旦匹配成功就终止匹配。如果多个中间件对同一个请求做处理时，可以调用next方法，意思就是匹配完我，还要接着匹配下一个中间件，哪个没写就到哪停止如：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;request&#39;, (req, res, next) &#x3D;&gt; &#123;~~~next();&#125;);</span><br></pre></td></tr></table></figure></li>
<li>就表示继续向下走匹配下一个中间件；</li>
<li>app.use()中间件用法：app.use()可以匹配所有的请求方式，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;~~~&#125;);</span><br></pre></td></tr></table></figure></li>
<li>直接传入请求处理函数，代表接受所有的请求，注意：此代码要写在所有中间件前面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(&#39;&#x2F;admin&#39;,(req, res, next) &#x3D;&gt; &#123;~~~&#125;);</span><br></pre></td></tr></table></figure></li>
<li>第一个参数也可以传入请求地址，代表无论什么请求方式，只要是这个请求地址就接受这个请求。</li>
</ul>
<h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><ul>
<li>在程序执行的过程中，不可避免地会出现一些无法预料的错误，比如文件读取失败，数据库连接失败，错误处理中间件是一个集中处理错误的地方</li>
<li>程序在运行过程中一旦出错是不能继续运行的，如果要让程序在出错之后还能继续运行，我们就需要在程序中捕获错误，加入错误处理。</li>
<li>错误一般可以分为两种：一种是应用逻辑错误，也就是bug，这些错误是可以在开发阶段解决的，还有另外一种错误，比如读文件时文件不存在，这样程序也会报错，这种错误无法在开发阶段预料到，所以这种错误就需要被捕获，然后再对错误进行妥善处理，才不会导致程序崩溃</li>
<li>如何定义错误处理中间件：错误处理中间件有四个形参，分别为：err错误对象，req请求对象，res响应对象，next方法,当出现了一个错误时，错误处理中间件就开始执行。</li>
<li>错误处理中间件只能捕获到同步代码执行出错，如果异步代码在执行的过程中出现了错误，错误处理中间件是无法捕捉到的，这时我们需要手动触发错误处理中间件，如何触发呢？当异步API执行出错时，需要调用next方法，并且将错误信息传递到next方法中就可以了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;错误处理中间件</span><br><span class="line">app.use((err, req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">    res.status(500).send(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="异步函数错误的捕获"><a href="#异步函数错误的捕获" class="headerlink" title="异步函数错误的捕获"></a>异步函数错误的捕获</h2><ul>
<li>node.js中，错误信息都是通过回调函数获取的，支持promise对象的异步API发生错误可以通过catch方法捕获。但是，如何捕获异步函数执行时的错误呢？try catch 可以捕获同步代码错误，也可以捕获异步函数错误，但是不能捕获其他类型的异步错误，如：回调函数的/Promise对象的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;index&#39;, async (req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        await readFile(&#39;.&#x2F;aaa.js&#39;);&#x2F;&#x2F;把可能会出错的代码写在这里</span><br><span class="line">    &#125;catch (ex) &#123;</span><br><span class="line">        next(ex);&#x2F;&#x2F;如果try中的代码发生了错误，则执行这里的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="构建模块化路由的基础代码"><a href="#构建模块化路由的基础代码" class="headerlink" title="构建模块化路由的基础代码"></a>构建模块化路由的基础代码</h2><blockquote>
<p>构建模块化路由</p>
</blockquote>
<ul>
<li>虽然可以根据app.get()方法或者app.post()方法来创建路由，但是在一个真实的项目当中，路由的数量往往是很多的，express提供了模块化构建路由的方式，可以将同一类型的模块放在同一模块中进行管理；</li>
<li>构建模块化路由的基础代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建路由对象</span><br><span class="line">const home &#x3D; express.Router();</span><br><span class="line">&#x2F;&#x2F; 为路由对象匹配请求路径</span><br><span class="line">app.use(&#39;&#x2F;home&#39;, home);</span><br><span class="line">&#x2F;&#x2F; 创建二级路由</span><br><span class="line">home.get(&#39;&#x2F;index&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.send(&#39;欢迎来到博客首页！&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h2><ul>
<li>首先在外部文件中创建好路由对象，而后在app.js文件中用require方法引入这些模块，然后对导入的路由进行路径匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;导入两个路由模块</span><br><span class="line">const home &#x3D; require(&#39;.&#x2F;route&#x2F;home&#39;);&#x2F;&#x2F;.js后缀可以省略</span><br><span class="line">const admin &#x3D; require(&#39;.&#x2F;route&#x2F;admin&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进行路径的匹配</span><br><span class="line">app.use(&#39;&#x2F;home&#39;, home);</span><br><span class="line">app.use(&#39;&#x2F;admin&#39;, admin);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="GET参数的获取"><a href="#GET参数的获取" class="headerlink" title="GET参数的获取"></a>GET参数的获取</h2><ul>
<li>Express框架为请求对象req新增了query属性，query属性的值是对象类型对象中存储的就是客户端发来的GET请求参数，也就是说，通过使用Express框架，我们不再需要通过引用URL模块对请求地址进行解析从而获取GET请求参数。</li>
<li><a target="_blank" rel="noopener" href="http://localhost:3000/index?name=zhangsan&amp;age=30&amp;gender=male">http://localhost:3000/index?name=zhangsan&amp;age=30&amp;gender=male</a></li>
<li>输入上面的，浏览器就会得到下面的GET请求参数，一个对象{“name”:”zhangsan”,”age”:”30”,”gender”:”male”}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入模块</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">&#x2F;&#x2F;创建网站服务器</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">app.get(&#39;&#x2F;index&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;获取GET请求参数</span><br><span class="line">    res.send(req.query);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="POST参数的获取"><a href="#POST参数的获取" class="headerlink" title="POST参数的获取"></a>POST参数的获取</h2><ul>
<li>Express中接受post参数需要借助第三方包 body-parser</li>
<li>首先npm install body-parser 下载第三方模块</li>
<li>执行以下代码</li>
<li>然后重新创建一个post.html文件</li>
<li>用浏览器执行该文件，输入用户名和密码</li>
<li>回车，就可以直接获取到一个数组，其中包含了用户名和密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入模块</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const bodyParser &#x3D; require(&#39;body-parser&#39;);</span><br><span class="line">&#x2F;&#x2F;创建网站服务器</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拦截所有请求</span><br><span class="line">&#x2F;&#x2F;extended:false   方法内部使用querystring模块处理请求参数的格式</span><br><span class="line">&#x2F;&#x2F;extended:true  方法内部使用第三方模块qs处理请求参数的格式</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:false&#125;))</span><br><span class="line"></span><br><span class="line">app.post(&#39;&#x2F;add&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.send(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="app-use-方法"><a href="#app-use-方法" class="headerlink" title="app.use()方法"></a>app.use()方法</h2><ul>
<li>app.use()方法中是需要传递一个响应处理函数的。其实也可以传递一个对象的方法，只要这个方法的返回值是一个函数即可这种方法和直接传递一个函数作用相同，但是有好处。好处就是可以针对这个方法中传递的不同参数进行不同的函数调用我们使用if语句来进行判断，满足这个条件的参数就调用这个函数满足另一个条件的就调用另一个函数这样做就会更加灵活。</li>
</ul>
<h2 id="Express路由参数"><a href="#Express路由参数" class="headerlink" title="Express路由参数"></a>Express路由参数</h2><ul>
<li>在Express框架中，传递和接受GET请求参数还有另外一种方式，路由参数这种方式可以让请求地址看起来非常的美观，也可以让路由代码更加易于阅读开发人员一眼就可以看出来请求当前路由需要传递哪些参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引入模块</span><br><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">&#x2F;&#x2F;创建网站服务器</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里的:id表示的是一个占位符，当前这个路由需要接受一个id作为参数</span><br><span class="line">app.get(&#39;&#x2F;index&#x2F;:id&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;接受post请求参数</span><br><span class="line">    res.send(req.params);</span><br><span class="line">    &#x2F;&#x2F;在浏览器中输入localhost:3000&#x2F;index&#x2F;zhangteng</span><br><span class="line">    &#x2F;&#x2F;页面中就会返回一个对象&#123;&quot;id&quot;:&quot;zhangteng&quot;&#125;</span><br><span class="line">    &#x2F;&#x2F;如果要传递多个参数可以继续添加占位符：&#x2F;index&#x2F;:id&#x2F;:name&#x2F;:age</span><br><span class="line">    &#x2F;&#x2F;在浏览器中输入localhost:3000&#x2F;index&#x2F;zhangteng&#x2F;Ryan&#x2F;22</span><br><span class="line">    &#x2F;&#x2F;页面就会显示一个对象：&#123;&quot;id&quot;:&quot;zhangteng&quot;,&quot;name&quot;:&quot;Ryan&quot;,&quot;age&quot;:&quot;22&quot;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="静态资源访问功能"><a href="#静态资源访问功能" class="headerlink" title="静态资源访问功能"></a>静态资源访问功能</h2><ul>
<li>在Express框架下，可以使用express.static可以方便地托管静态文件</li>
<li>例如：img文件，CSS文件，JavaScript文件等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拼接路径,__dirname获取当前文件夹所在的路径</span><br><span class="line">&#x2F;&#x2F;path.join(__dirname, &#39;public&#39;);</span><br><span class="line">&#x2F;&#x2F;将拼接的路径放在static这个方法里面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现静态资源访问功能</span><br><span class="line">&#x2F;&#x2F;注意，也可以为这个路径指定一个虚拟路径</span><br><span class="line">&#x2F;&#x2F;如：app.use(&#39;&#x2F;static&#39;, express.static(path.join(__dirname, &#39;public&#39;)));</span><br><span class="line">&#x2F;&#x2F;这样访问路径就成了：locahost:3000&#x2F;static&#x2F;要打开的文件名即可&#x2F;或者继续向里打开</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, &#39;public&#39;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行当前代码</span><br><span class="line">&#x2F;&#x2F;在浏览器中直接输入localhost:3000&#x2F;要打开的文件名即可&#x2F;或者继续向里打开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="Express中如何使用模板引擎"><a href="#Express中如何使用模板引擎" class="headerlink" title="Express中如何使用模板引擎"></a>Express中如何使用模板引擎</h2><ul>
<li>模板引擎依然选择art-template,官方为了让这个引擎在框架中更好使用</li>
<li>基于原有模板引擎又进行了一次封装:express-art-template</li>
<li>使用如下命令进行下载：cnpm install art-template express-art-template<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.告诉express框架使用什么模板引擎渲染什么后缀的模板文件</span><br><span class="line">&#x2F;&#x2F;参数一：模板的后缀；参数二:使用的模板引擎</span><br><span class="line">app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.告诉express框架模板存放的位置是什么,参数一：默认的；参数二：文件夹的名字</span><br><span class="line">app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.告诉express框架模板的默认后缀是什么</span><br><span class="line">app.set(&#39;view engine&#39;, &#39;art&#39;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;index&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;1.拼接了模板路径</span><br><span class="line">    &#x2F;&#x2F;2.拼接了模板后缀</span><br><span class="line">    &#x2F;&#x2F;3.哪一个模板和哪一个路径进行拼接</span><br><span class="line">    &#x2F;&#x2F;4.将拼接结果响应给客户端</span><br><span class="line">    res.render(&#39;index&#39;, &#123;</span><br><span class="line">        msg:&quot;message&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;list&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.render(&#39;list&#39;, &#123;</span><br><span class="line">        msg:&#39;list page&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="app-local对象"><a href="#app-local对象" class="headerlink" title="app.local对象"></a>app.local对象</h2><ul>
<li>在真实的项目开发中有这样一种场景：在不同页面中总会有一些公共区域</li>
<li>这些公共区域要展示的数据都是一样的，在代码中要如何查询这个公共数据呢？</li>
<li>最直接的方法就是在不同的页面路由当中都去查询这个相同的数据，然后再用render方法将数据填充到模板当中，这样会产生很多的冗余代码</li>
<li>如何让查询公共数据的代码只写一次，要用的都可以使用呢？</li>
<li>app下有一个locals对象，我们可以将公共数据作为locals对象下面的属性，在所有的模板中都是可以获取到的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.locals().users &#x3D; [&#123;</span><br><span class="line">    name:&#39;zhangsan&#39;,</span><br><span class="line">    age:20</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    name:&#39;lisi&#39;,</span><br><span class="line">    age:30</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/AJAX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/AJAX/" class="post-title-link" itemprop="url">AJAX</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 19:05:02 / Modified: 19:06:10" itemprop="dateCreated datePublished" datetime="2020-10-31T19:05:02+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AJAX-简介"><a href="#AJAX-简介" class="headerlink" title="AJAX 简介"></a>AJAX 简介</h2><ul>
<li>全称：Asyncchronous Javascript And XML,就是异步的JS和XML</li>
<li>过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。</li>
<li>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</li>
<li>使用场景很多，如搜索框的关键字提醒，注册界面如用户名重复，hover效果中的懒加载，使用时加载，不使用时就不加载，还有页面到底之后重新加载新的，像朋友圈。</li>
<li>数据交换更加快速，用户的体验也会更好</li>
</ul>
<h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><ul>
<li>XML 可扩展标记语言</li>
<li>XML 被设计用来传输和存储数据</li>
<li>XML和HTML 类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全部都是自定义标签，用来表示一些数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;student&gt;</span><br><span class="line">  &lt;name&gt;孙悟空&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;age&gt;18&lt;&#x2F;age&gt;</span><br><span class="line">  &lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">&lt;&#x2F;student&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="AJAX的优缺点"><a href="#AJAX的优缺点" class="headerlink" title="AJAX的优缺点"></a>AJAX的优缺点</h2><blockquote>
<p>AJAX的优点：</p>
</blockquote>
<ul>
<li>可以无需刷新而与服务器端进行通信；</li>
<li>允许根据用户事件来更新页面部分内容；<blockquote>
<p>AJAX的缺点：</p>
</blockquote>
</li>
<li>没有浏览历史，不能回退；</li>
<li>存在跨域问题（同源），从这个服务向另一个服务发送请求不被允许；</li>
<li>SEO不友好，爬虫无法爬到一些AJAX信息</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul>
<li>HTTP(hypertext transport protocol) 超文本传输协议，协议详细规定了浏览器和万维网之间互相通信的规则，就是一种约定，一种规则<blockquote>
<p>请求报文</p>
</blockquote>
</li>
<li>行    POST  /URL地址  HTTP/1.1(HTTP的版本)</li>
<li>头    <ul>
<li>Host: atguigu.com</li>
<li>Cookie: name=guigu   </li>
<li>Content-type: application/x-www-form-urlencoded</li>
<li>User-Agent: chrome 83</li>
</ul>
</li>
<li>空行    固定的，必须要有</li>
<li>体    username=admin&amp;password=admin    如果时GET请求，请求体为空，如果为POST请求，请求体可以不为空；<blockquote>
<p>响应报文</p>
</blockquote>
</li>
<li>行    HTTP/1.1   200(状态码)   OK(状态字符串)</li>
<li>头    <ul>
<li>Content-Type: text/html;charset=utf-8</li>
<li>Content-length: 2048</li>
<li>Content-encoding: gzip</li>
</ul>
</li>
<li>空行</li>
<li>体   这里就是网页的html代码</li>
</ul>
<h2 id="chrome查看报文"><a href="#chrome查看报文" class="headerlink" title="chrome查看报文"></a>chrome查看报文</h2><ul>
<li>F12打开控制台，点击network</li>
<li>所有的发送给服务器的请求都在这里显示</li>
<li>点击随便一个请求，在出现的新框中有：Headers Preview Response Initiator Iiming Cookies</li>
<li>其中Headers中可以查看请求头和响应头(点击view source)，以及将URL地址进行解析后的结果</li>
<li>在Pesponse中可以查看响应体</li>
<li>如果是一个GET请求，请求报文查看：Request Headers 和 Query String Parameters(URL解析结果)  响应报文查看：Response Headers 和 Response</li>
<li>如果是一个POST请求，请求报文查看：Request Headers 和 Form Data(账号密码)  响应报文查看：Response Headers 和 Response</li>
</ul>
<h2 id="express基本使用"><a href="#express基本使用" class="headerlink" title="express基本使用"></a>express基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.引入express</span><br><span class="line">const express &#x3D; require(&quot;express&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.创建应用对象</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.创建路由规则,request是对请求报文的封装，response是对响应报文的封装</span><br><span class="line">app.get(&#39;&#x2F;&#39;, (request, response)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;设置响应</span><br><span class="line">    response.send(&#39;HELLO EXPRESS&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4.监听端口启动服务</span><br><span class="line">app.listen(8000, ()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;服务器已经启动，8000端口监听中...&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="AJAX的基本使用"><a href="#AJAX的基本使用" class="headerlink" title="AJAX的基本使用"></a>AJAX的基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点击发送请求&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;result&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;获取button元素</span><br><span class="line">        const btn &#x3D; document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line"></span><br><span class="line">        btn.onclick &#x3D; function()&#123;</span><br><span class="line">            &#x2F;&#x2F;接下来就进行AJAX操作了</span><br><span class="line">            &#x2F;&#x2F;1.创建对象</span><br><span class="line">            const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">            const result &#x3D; document.getElementById(&quot;result&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.初始化，设置请求的方法和URL</span><br><span class="line">            xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;server&#39;);</span><br><span class="line">            &#x2F;&#x2F;3.发送</span><br><span class="line">            xhr.send();</span><br><span class="line">            &#x2F;&#x2F;4.事件绑定，处理服务端返回的结果</span><br><span class="line">            &#x2F;&#x2F;on表示当...的时候，readystate是xhr对象中的属性，表示状态（0表示未初始化，1表示open方法调用完毕，2表示send方法调用完毕，3表示服务端返回的部分结果，4表示服务端返回了所有结果）</span><br><span class="line">            xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">                &#x2F;&#x2F;判断(服务端返回了所有结果)</span><br><span class="line">                if(xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">                    &#x2F;&#x2F;判断响应状态码 200 404 403 401 500,其中2开头的都表示成功</span><br><span class="line">                    if(xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt;&#x3D; 300)&#123;</span><br><span class="line">                        &#x2F;&#x2F;处理结果  行，头，空行，体</span><br><span class="line">                        &#x2F;&#x2F;1.响应行</span><br><span class="line">                        &#x2F;&#x2F; console.log(xhr.status);&#x2F;&#x2F;状态码</span><br><span class="line">                        &#x2F;&#x2F; console.log(xhr.statusText);&#x2F;&#x2F;状态字符串</span><br><span class="line">                        &#x2F;&#x2F; console.log(xhr.getAllResponseHeaders());&#x2F;&#x2F;所有响应头</span><br><span class="line">                        &#x2F;&#x2F; console.log(xhr.response);&#x2F;&#x2F;响应体s</span><br><span class="line">                        &#x2F;&#x2F;设置result的文本</span><br><span class="line">                        result.innerHTML &#x3D; xhr.response;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="AJAX设置请求参数"><a href="#AJAX设置请求参数" class="headerlink" title="AJAX设置请求参数"></a>AJAX设置请求参数</h2><ul>
<li>在原生AJAX案例中GET.html文件中</li>
<li>xhr.open(‘GET’, ‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8000/server&#39;">http://127.0.0.1:8000/server&#39;</a>);</li>
<li>直接在如上的URL后面加上: ?a=100&amp;b=200&amp;c=300即可</li>
<li>在网页的nerwork中点击Headers 点击Query String Parameters，其中就会显示所有的参数，如下：<ul>
<li>a: 100</li>
<li>b: 200</li>
<li>c: 300</li>
</ul>
</li>
</ul>
<h2 id="AJAX发送POST请求"><a href="#AJAX发送POST请求" class="headerlink" title="AJAX发送POST请求"></a>AJAX发送POST请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;获取元素对象</span><br><span class="line">        const result &#x3D; document.getElementById(&quot;result&quot;);</span><br><span class="line">        &#x2F;&#x2F;绑定事件</span><br><span class="line">        result.addEventListener(&quot;mouseover&quot;, function()&#123;</span><br><span class="line">            &#x2F;&#x2F;1.创建对象</span><br><span class="line">            const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">            &#x2F;&#x2F;2.初始化，设置类型和URL</span><br><span class="line">            xhr.open(&#39;POST&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;server&#39;);</span><br><span class="line">            &#x2F;&#x2F;设置请求头</span><br><span class="line">            xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">            &#x2F;&#x2F;3.发送</span><br><span class="line">            xhr.send(&#39;a&#x3D;100&amp;b&#x3D;200&amp;c&#x3D;300&#39;);</span><br><span class="line">            &#x2F;&#x2F;4.事件绑定</span><br><span class="line">            xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">                &#x2F;&#x2F;判断</span><br><span class="line">                if(xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">                    if(xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt;&#x3D; 300)&#123;</span><br><span class="line">                        &#x2F;&#x2F;处理服务端返回的结果</span><br><span class="line">                        result.innerHTML &#x3D; xhr.response;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="POST请求设置请求体"><a href="#POST请求设置请求体" class="headerlink" title="POST请求设置请求体"></a>POST请求设置请求体</h2><ul>
<li>可以直接在xhr.send()中添加参数如：</li>
<li>xhr.send(‘a=100&amp;b=200&amp;c=300’);</li>
<li>然后在网页中的nerwork 中 Headers 中的 Request Payload 中查看参数</li>
<li>其中显示为：a=100&amp;b=200&amp;c=300</li>
<li>除了以上的方式外，还可以使用</li>
<li>xhr.send(‘a:100&amp;b:200&amp;c:300’);</li>
<li>xhr.send(‘1234352354235’);</li>
<li>这些方式进行传递</li>
</ul>
<h2 id="AJAX设置请求头信息"><a href="#AJAX设置请求头信息" class="headerlink" title="AJAX设置请求头信息"></a>AJAX设置请求头信息</h2><ul>
<li>设置请求头信息，在open方法后面添加xhr.setRequestHeader(‘Content-type’, ‘application/x-www-form-urlencoded’);这是用来设置请求体内容的类型的，固定写法。</li>
<li>xhr.setRequestHeader(‘name’, ‘hhhhhh’);也可以自定义,不过这时浏览器会报错，因为我们是自定义的，而不是预定义的，我们需要在服务器server.js中的app.post(){}中设置response.setHeader(‘Access-Control-Allow-Headers’, ‘*’);</li>
<li>还是不行，需要将app.post中的post改为all</li>
</ul>
<h2 id="服务端响应JSON数据"><a href="#服务端响应JSON数据" class="headerlink" title="服务端响应JSON数据"></a>服务端响应JSON数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">        const result &#x3D; document.getElementById(&quot;result&quot;);</span><br><span class="line">        &#x2F;&#x2F;绑定键盘按下事件</span><br><span class="line">        window.onkeydown &#x3D; function()&#123;</span><br><span class="line">            &#x2F;&#x2F;发送请求</span><br><span class="line">            const xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">            &#x2F;&#x2F;设置响应体数据的一个类型</span><br><span class="line">            xhr.responseType &#x3D; &#39;json&#39;;</span><br><span class="line">            &#x2F;&#x2F;初始化</span><br><span class="line">            xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;json-server&#39;);</span><br><span class="line">            &#x2F;&#x2F;发送</span><br><span class="line">            xhr.send();</span><br><span class="line">            &#x2F;&#x2F;事件绑定</span><br><span class="line">            xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">                if(xhr.readyState &#x3D;&#x3D;&#x3D; 4)&#123;</span><br><span class="line">                    if(xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt;&#x3D; 300)&#123;</span><br><span class="line">                        &#x2F;&#x2F;处理服务端返回结果</span><br><span class="line">                        &#x2F;&#x2F; console.log(xhr.response);</span><br><span class="line">                        &#x2F;&#x2F; result.innerHTML &#x3D; xhr.response;</span><br><span class="line">                        &#x2F;&#x2F;如上方法在数据较多时不方便，我们可以手动对数据进行转换</span><br><span class="line">                        let data &#x3D; JSON.parse(xhr.response);</span><br><span class="line">                        console.log(data);</span><br><span class="line">                        result.innerHTML &#x3D; data.name;</span><br><span class="line">                        &#x2F;&#x2F;还可以自动转换，要设置响应体数据的类型,推荐</span><br><span class="line">                        result.innerHTML &#x3D; xhr.response.name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/MongoDB-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/MongoDB-md/" class="post-title-link" itemprop="url">MongoDB.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 18:43:41 / Modified: 18:56:44" itemprop="dateCreated datePublished" datetime="2020-10-31T18:43:41+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">数据库（database）</span><br><span class="line">      &gt; 数据库是按照数据结构来组织，存储，和管理数据的仓库</span><br><span class="line">      &gt; 我们的程序都是在内存中运行，一旦程序运行结束或者计算机断电，</span><br><span class="line">        程序中的数据都会都会消失</span><br><span class="line">      &gt; 所以我们就需要将一些程序运行的数据持久化到硬盘中去，确保数</span><br><span class="line">        据的安全性，而数据库就是数据持久化的最佳选择</span><br><span class="line">      &gt; 说白了，数据库就是存储数据的仓库</span><br><span class="line"></span><br><span class="line">    数据库的分类</span><br><span class="line">      &gt; 关系型数据库(RDBMS)</span><br><span class="line">        &gt; 如：MySQL Oracle DB2 SQL Server,关系数据库中全都是表</span><br><span class="line">      &gt; 非关系型数据库(NoSQL)-not only SQL</span><br><span class="line">        &gt; MongoDB、Redis,是一种键值对数据库，文档数据库</span><br></pre></td></tr></table></figure>


<h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MongoDB简介</span><br><span class="line">    &gt; 是为快速开发互联网Web应用而设计的数据库系统；</span><br><span class="line">    &gt; MongoDB的设计目标是极简，灵活，作为Web应用栈的一部分；</span><br><span class="line">    &gt; MongoDB的数据模型是面向文档的，所谓的文档是一种类似于JSON的结构，简单理解</span><br><span class="line">      MongoDB这个数据库中存的是各种各样的JSON</span><br><span class="line">    &gt; 三个概念：</span><br><span class="line">           1.数据库(database)</span><br><span class="line">               -是一个仓库，在仓库中可以存放集合</span><br><span class="line">           2.集合(collection)</span><br><span class="line">               -集合类似于数组，在集合中可以存放文档</span><br><span class="line">           3.文档(document)</span><br><span class="line">               -文档是数据库中最小的单位，我们存储和操作的内容都是文档</span><br><span class="line">           注意：MongoDB中，数据库和集合都不需要我们手动创建，当我们创建文档时</span><br><span class="line">                如果文档所在的集合或数据库不存在的话，会自动创建数据库和集合；</span><br><span class="line"></span><br><span class="line">    &gt; 安装mongoDB，配置环境变量，在c盘根目录创建一个文件夹data，在data中新建一个文件夹</span><br><span class="line">      db，打开cmd命令行窗口输入mongod启动mongodb服务器，然后再打开一个cmd窗口输入mongo</span><br><span class="line">      再回车，出现小箭头就表示成功连接到了数据库</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB基本操作"><a href="#MongoDB基本操作" class="headerlink" title="MongoDB基本操作"></a>MongoDB基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Mongo的cmd窗口也叫Mongo shell</span><br><span class="line"> </span><br><span class="line"> -使用步骤：</span><br><span class="line">          1.需要打开数据库：mongod</span><br><span class="line">          2.重新打开一个新的命令行：mongo  即可使用</span><br><span class="line"></span><br><span class="line"> -基本指令</span><br><span class="line">          show dbs ：显示当前所有的数据库</span><br><span class="line">          use 数据库名字：进入到指定的数据库中</span><br><span class="line">          db：表示当前所处的数据库</span><br><span class="line">          show collections：显示数据库中所有的集合</span><br><span class="line"> MongoDB中的属性值也可以是一个文档，此时叫做内嵌文档</span><br><span class="line"> 如果要查询内嵌文档，可以使用.的方式一层一层查找，注意这时的属性名要加引号，用的较多</span><br><span class="line"></span><br><span class="line"> -数据库的CRUD(增删改查)操作</span><br><span class="line">         -向数据库中插入文档</span><br><span class="line">             db.&lt;collections&gt;.insert(doc):向集合中插入一个或多个文档，一个就传一个对象，多个就传一个数组；</span><br><span class="line">	db.&lt;collections&gt;.find():查询当前集合中的所有文档</span><br><span class="line">	向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加</span><br><span class="line">	该属性来作为文档的唯一标识，确保数据的唯一性，_id可以自己指定，数据库就不会添加了；</span><br><span class="line">	db.collections.insertOne();插入一个</span><br><span class="line">	db.collections.insertMany();插入多个</span><br><span class="line">-在数据库中查询文档</span><br><span class="line">	db.collections.find():用来查询集合中所有符合条件的文档：</span><br><span class="line">		括号里可以接受一个对象作为条件参数，如&#123;属性名：属性值&#125;</span><br><span class="line">		而且可以添加多个键值对进行查询</span><br><span class="line">		find()返回的是一个数组</span><br><span class="line">	db.collections.findOne():用来查询集合中符合条件的第一个文档</span><br><span class="line">		findOne()返回的是一个对象</span><br><span class="line">	db.collections.find(&#123;&#125;).count():查询所有结果的数量</span><br><span class="line">		返回值数值，表示所有文档的数量</span><br><span class="line">-修改数据库中的文档</span><br><span class="line">	db.collections.update(查询条件，新对象)：</span><br><span class="line">		update默认情况下会使用新对象来替换旧对象，即原来的对象中所有的属性都没了，换了新对象的属性；</span><br><span class="line">		如果需要修改指定的属性，而不是替换整个对象，则需要使用修改操作符：$set 用来修改文档中的指定属性</span><br><span class="line">		$set   修改文档的指定属性</span><br><span class="line">		$unset  用来删除文档的指定属性</span><br><span class="line">		$push  用来向数组中添加一个新的元素，此操作符可以添加重复元素</span><br><span class="line">		$addToSet  用来向数组中添加一个新的元素，注意，此操作符不会添加重复元素</span><br><span class="line">		使用方法：db.collections.update(&#123;找到要修改的文档_id&#125;，&#123;$set:&#123;这里写要改动的键值对&#125;&#125;;</span><br><span class="line">		update()默认情况下只可以修改一个文档；</span><br><span class="line">	db.collections.updateOne():修改一个符合条件的文档</span><br><span class="line">	db.collections.updateMany():同时修改多个符合条件的文档</span><br><span class="line">	db.collections.replaceOne():替换一个文档</span><br><span class="line">	</span><br><span class="line">-删除文档</span><br><span class="line">	db.collections.remove();</span><br><span class="line">		默认删除符合条件的所有文档，如果第二个参数为true，则只会删除一个</span><br><span class="line">		如果只传递一个空对象.remove(&#123;&#125;)作为参数，则会删除集合中的所有文档，即清空集合(性能略差)；</span><br><span class="line">		db.collections.drop():删除集合</span><br><span class="line">		db.dropdatabase();删除数据库</span><br><span class="line">		一般数据库中的数据都不会删除，所以删除的方法很少调用</span><br><span class="line">		一般会在数据中添加一个字段(字段也就是一个属性)，来表示数据是否被删除</span><br><span class="line">	db.collections.deleteOne()：删除一个</span><br><span class="line">	db.collections.deleteMany()：删除多个</span><br><span class="line">		remove()可以通过条件来删除文档，传递方式与find()一样</span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">如果要向数据库中插入多条数据，则使用一个for循环</span><br><span class="line">	但是速度很慢，希望插入速度快一点，如何一次性插入2000条数据？</span><br><span class="line">	可以这样：创建一个数组，先把要存的数据添加进数组里，再将数组一次添加进数据库。</span><br><span class="line">	注意，数据库的方法尽量少调用，因为性能较差。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	查询操作符</span><br><span class="line">		可以传递多个条件</span><br><span class="line">			$gt  大于</span><br><span class="line">			$lt  小于</span><br><span class="line">			$inc  自增</span><br><span class="line">			$or   或者，表示且的关系</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">	查询集合中的前10条数据</span><br><span class="line">		db.collections.find().limit(10); &#x2F;&#x2F;设置显示的上限</span><br><span class="line">		在开发时，我们绝对不会执行不带条件的查询，因为数据太多了，浪费性能,db.collections.find();</span><br><span class="line">		</span><br><span class="line">	查询集合中的11到20条数据，也就是分页，每页显示10条数据</span><br><span class="line">		db.collections.find().skip(10).limit(10);跳过前10条数据，然后再显示10条数据。</span><br><span class="line">		</span><br><span class="line">	总结分页操作：skip(页码-1*每页显示的条数).limit(每页显示的条数);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	查询文档时，默认情况是按照_id的值进行排列（升序）</span><br><span class="line">			sort()可以用来指定文档排序的规则，sort()需要传递一个对象来指定排序规则：1表示升序，-1表示降序</span><br><span class="line">			skip limit sort  之间可以任意顺序，软件会自动进行排序</span><br><span class="line"></span><br><span class="line">	在查询时，可以在第二个参数的位置来设置查询结果的投影，可以理解为只显示所有数据中的某一项</span><br><span class="line">			第一个参数传递一个空对象</span><br><span class="line">			第二个参数传递一个对象 &#123;name:1,_id:0&#125;  表示显示name，不显示id；</span><br></pre></td></tr></table></figure>

<h2 id="文档之间的关系"><a href="#文档之间的关系" class="headerlink" title="文档之间的关系"></a>文档之间的关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文档之间的关系</span><br><span class="line">		一对一（one to one)夫妻</span><br><span class="line">				在MongoDB中，可以通过内嵌文档的形式来体现出一对一的关系</span><br><span class="line">				</span><br><span class="line">		一对多（one to many）&#x2F;多对一  父母和孩子  用户和订单</span><br><span class="line">				也可以使用内嵌文档的形式来体现一对多的关系</span><br><span class="line">				主要使用在另一个集合中将一的_id 设置为多的一个属性，这样就形成了对应关系</span><br><span class="line">				每一个“多”中都有一个“一”的_id，就ok了</span><br><span class="line">				</span><br><span class="line">		多对多（many to many）分类和商品  老师和学生</span><br><span class="line">				和一对多类似，只不过上述将_id设置给了“多”，要实现多对多，只要将这个_id</span><br><span class="line">				改为一个数组即可；</span><br></pre></td></tr></table></figure>

<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Mongoose简介</span><br><span class="line">		- 之前我们都是通过shell来完成对数据库的各种操作的，但是在开发中大部分时间我们都需要通过</span><br><span class="line">		  程序来完成对数据库的各种操作</span><br><span class="line">		- Mongoose就是一个让我们可以通过Node来操作MongoDB的模块；</span><br><span class="line">		- Mongoose是一个对象文档模型库（ODM），他对Node原生的MongoDB模块进行了进一步的优化封装，并提供</span><br><span class="line">		  了更多的功能；</span><br><span class="line">		- 在大多数情况下，它用来把结构化的模式应用到一个MongoDB集合，并提供了验证和类型转换</span><br><span class="line">		- 简单理解：ODM指的是object Document Model ，其中Object对象指的就是js对象，而doucument文档指的</span><br><span class="line">		  就是数据库中的文档，把数据库中所存的这些文档，将其映射成了JS中的一个一个对象，我们通过对对象</span><br><span class="line">		  的操作就可以操作数据库了，他的作用就是让我们以面向对象的形式去操作数据库；</span><br><span class="line">		  </span><br><span class="line">		  </span><br><span class="line">	Mongoose的好处</span><br><span class="line">		- 可以为文档创建一个模式结构（Schema），可叫做约束，在数据进入我们的数据库之前进行一次验证，符合</span><br><span class="line">		  相关的格式才可以进入，确保数据是对的，优化了MongoDB的缺点；</span><br><span class="line">		- 数据可以通过类型转换转换为对象模型</span><br><span class="line">		- 可以使用中间件来应用业务逻辑挂钩；web服务器</span><br><span class="line">		- 比Node原生的MongoDB驱动更容易；</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	Mongoose为我们提供了几个新的对象</span><br><span class="line">		- Schema（模式对象）</span><br><span class="line">			定义约束了数据库中的文档结构</span><br><span class="line">		- Model</span><br><span class="line">			Model对象作为集合中的所有文档的表示，相当于MongoDB数据库中的collection</span><br><span class="line">		- Document</span><br><span class="line">			表示集合中的具体文档，相当于集合中的一个具体文档；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Mongoose使用步骤</span><br><span class="line">		1.下载安装Mongoose</span><br><span class="line">				cnpm i mongoose --save</span><br><span class="line">		2.在项目中引入mongoose</span><br><span class="line">				var mongoose &#x3D; require(&quot;mongoose&quot;);</span><br><span class="line">		3.连接MongoDB数据库</span><br><span class="line">				mongoose.connect(&#39;mongodb:&#x2F;&#x2F;数据库的ip地址:端口号&#x2F;数据库名&#39;,);</span><br><span class="line">				如果端口号是默认端口号（27017），则可以省略不写</span><br><span class="line">		4.断开数据库的连接（一般不需要调用）</span><br><span class="line">				mongoose.disconnect();</span><br><span class="line">				一般情况下，只需要连接数据库一次，连接一次之后，除非项目停止服务器关闭，否则连接不会断开；</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	监听MongoDB数据库的连接状态</span><br><span class="line">		- 在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库的连接</span><br><span class="line">		  通过监视该对象的状态，可以来监听数据库的连接与断开</span><br><span class="line">				mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;);数据库连接成功的事件</span><br><span class="line">				mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;);数据库连接断开的事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Schema和Model</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			赋值：var Schema &#x3D; mongoose.Schema;</span><br><span class="line">			创建Schema对象：  var stuSchema &#x3D; new Schema&#123;</span><br><span class="line">								name:String,</span><br><span class="line">								age:Number,</span><br><span class="line">								address:String,</span><br><span class="line">								gender:&#123;type:String,default:&quot;female&quot;&#125;&#x2F;&#x2F;可以设置默认值</span><br><span class="line">								&#125;</span><br><span class="line">			通过Schema创建model：var StuModel &#x3D; mongoose.model(modelname,schema);&#x2F;&#x2F;modelname要映射的集合名字</span><br><span class="line">								 用上述建立的schema对象进行约束；</span><br><span class="line">			向数据库中插入文档：</span><br><span class="line">								StuModel.create(要插入的文档, function(err)&#123;</span><br><span class="line">									if(!err)&#123;console.log(&quot;插入成功&quot;)&#125;;</span><br><span class="line">								&#125;);</span><br><span class="line">			mongoose会自动将集合名变为复数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Model中的方法</span><br></pre></td></tr></table></figure>

<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Model的操作</span><br><span class="line">		-有了Model，我们就可以对数据库进行一些增删改查的工作了</span><br><span class="line">		</span><br><span class="line">		增</span><br><span class="line">		-model.create(doc(s),callback);用来创建一个文档并添加到数据库中,可以传一个或多个对象；</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		查</span><br><span class="line">		-model.find(conditions,[projection],[options],[callback]);</span><br><span class="line">				查询所有符合条件的文档，总会返回一个数组</span><br><span class="line">		-model.findById(id,[projection],[options],[callback]);</span><br><span class="line">				根据文档的ID属性查询文档；</span><br><span class="line">		-model.findOne(conditions,[projection],[options],[callback]);</span><br><span class="line">				查询符合条件的第一个文档,总会返回一个具体的文档对象	</span><br><span class="line">		参数： </span><br><span class="line">				conditions: 查询的条件</span><br><span class="line">				projection: 投影，可以设置你想要的字段，不要id的话前面加-号；</span><br><span class="line">							两种方式：&#123;name:1,_id:0&#125;  或者  &quot;name -_id&quot;</span><br><span class="line">				options: 查询选项（skip limit）</span><br><span class="line">				callback: 回调函数，必须传</span><br><span class="line"></span><br><span class="line">		改</span><br><span class="line">		Model.update(conditions,doc,[options],[callback]);</span><br><span class="line">		Model.updateMany(conditions,doc,[options],[callback]);</span><br><span class="line">		Mode.updateOne(conditions,doc,[options],[callback]);</span><br><span class="line">		Model.replaceOne(conditions,doc,[options],[callback]);</span><br><span class="line">				用来修改一个或多个文档</span><br><span class="line">				参数：</span><br><span class="line">						conditions: 查询的条件；</span><br><span class="line">						doc: 修改后的对象；</span><br><span class="line">						options: 配置参数；</span><br><span class="line">						callback: 回调函数；</span><br><span class="line">	</span><br><span class="line">		删</span><br><span class="line">		Model.remove(conditions, callback);</span><br><span class="line">		Model.deleteOne(conditions, callback);</span><br><span class="line">		Model.deleteMany(conditions, callback);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Model.count(conditions, callback);用来统计文档的数量</span><br></pre></td></tr></table></figure>

<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Document 和 集合中的文档一一对应，Document是Model的一个实例，通过</span><br><span class="line">	Model查询到的结果都是Document；</span><br><span class="line">	</span><br><span class="line">	Document的方法#</span><br><span class="line">			-save([options], [fn])</span><br><span class="line">			-update(update, [options], [callback])</span><br><span class="line">			-remove([callback])</span><br><span class="line">			-get(name)：获取文档中的指定属性值</span><br><span class="line">			-set(neme, value):设置文档的指定属性值</span><br><span class="line">			-id  :获取文档的ID属性值</span><br><span class="line">			-ToJSON() :转换为一个JSON对象</span><br><span class="line">			-ToObject()  ：将Document对象转换为一个普通的JS对象，这样document对象的属性和方法都不能使用了</span><br><span class="line">			               有时候需要删属性时可以使用</span><br></pre></td></tr></table></figure>

<h2 id="mongoose的模块化"><a href="#mongoose的模块化" class="headerlink" title="mongoose的模块化"></a>mongoose的模块化</h2><ul>
<li>可以在外部文件写一个模块，就叫做connect_mongo,专门用来连接数据库，这样</li>
<li>要使用的时候，直接require(“这里写connect_mongo的路径”)，就可以直接使用；</li>
<li>另一个文件专门用来创建模型对象</li>
<li>代码复用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/19-cookie%E3%80%81localStorage%E3%80%81sessionStorage%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/19-cookie%E3%80%81localStorage%E3%80%81sessionStorage%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">19.cookie、localStorage、sessionStorage区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 15:41:09 / Modified: 15:41:30" itemprop="dateCreated datePublished" datetime="2020-10-31T15:41:09+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cookie、localStorage、sessionStorage区别"><a href="#cookie、localStorage、sessionStorage区别" class="headerlink" title="cookie、localStorage、sessionStorage区别"></a>cookie、localStorage、sessionStorage区别</h2><ul>
<li>cookie可以设置失效时间，但没有自己的存取取的方法，需要时封装，每次请求时跟随请求发送,而localStorage和sessionStorage可以有自己存取的方法例如：setItem(),getItem(),removeItem(),clear() 如：localStorage.setItem(‘属性’，值) </li>
<li>cookie:由服务器生成，可设置失效时间，如果在浏览器端生成Cookie，默认关闭浏览器后失效，大小4k左右，与服务器通信每次都会携带在http请求头中，如果使用cookie保存过多数据会带来性能问题，要程序员自己封装，原生的接口不友好；</li>
<li>localStorage：除非被清除，否则永久保存，大小一般为5M，仅在浏览器中保存，不参与服务器的通信，原生接口可以，也可以自己封装来对Object和Array有更好的支持；</li>
<li>sessionStorage：与上面的区别就是仅在当前会话下有效，关闭页面或者浏览器后被清除；</li>
</ul>
<h2 id="将一个函数的arguments转化为真正的数组"><a href="#将一个函数的arguments转化为真正的数组" class="headerlink" title="将一个函数的arguments转化为真正的数组"></a>将一个函数的arguments转化为真正的数组</h2><ul>
<li>arguments是一个对象，每个对象都有，可以使用</li>
<li>ES6提供一个方法，Array.form(arguments)来完成这个操作；</li>
</ul>
<h2 id="原生js获取其指定元素下面的所有元素节点"><a href="#原生js获取其指定元素下面的所有元素节点" class="headerlink" title="原生js获取其指定元素下面的所有元素节点"></a>原生js获取其指定元素下面的所有元素节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var box &#x3D; document.getElementById(&#39;box&#39;);</span><br><span class="line">console.log(box.getElementByTagName(&#39;*&#39;));</span><br></pre></td></tr></table></figure>

<h2 id="给Array对象增加一个原型方法，功能是删除数组中重复的项"><a href="#给Array对象增加一个原型方法，功能是删除数组中重复的项" class="headerlink" title="给Array对象增加一个原型方法，功能是删除数组中重复的项"></a>给Array对象增加一个原型方法，功能是删除数组中重复的项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique &#x3D; function()&#123;</span><br><span class="line">   var brr &#x3D; [],</span><br><span class="line">      obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for(var i&#x3D;0;i&lt;this.length;i++)&#123;</span><br><span class="line">    if(!obj[this[i]])&#123;</span><br><span class="line">      obj[this[i]] &#x3D; true;</span><br><span class="line">      brr.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return brr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.unique());</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/18-let%E5%92%8Cconst%E5%8C%BA%E5%88%AB%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/18-let%E5%92%8Cconst%E5%8C%BA%E5%88%AB%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">18.let和const区别、数据类型隐式转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 15:40:40 / Modified: 15:40:50" itemprop="dateCreated datePublished" datetime="2020-10-31T15:40:40+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ES6语法了解多少，const和let的区别"><a href="#ES6语法了解多少，const和let的区别" class="headerlink" title="ES6语法了解多少，const和let的区别"></a>ES6语法了解多少，const和let的区别</h2><blockquote>
<p>let</p>
</blockquote>
<ul>
<li>变量不能重复赋值；</li>
<li>let只在其作用域中起作用，外部无法使用；</li>
<li>不存在变量提升；</li>
<li>不影响作用域链，内部没有找到还是会去外部作用域找；<blockquote>
<p>const</p>
</blockquote>
</li>
<li>用来定义常量，如不能修改的量；</li>
<li>一定要赋初始值；</li>
<li>也是块级作用域中起作用；</li>
<li>对于const声明的数组或者对象进行修改是可以的，所以以后这两者多用const；</li>
</ul>
<h2 id="数据类型的隐式转换"><a href="#数据类型的隐式转换" class="headerlink" title="数据类型的隐式转换"></a>数据类型的隐式转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(true+1); &#x2F;&#x2F; 2 true隐式转换为1</span><br><span class="line">alert(&#39;name&#39;+true); &#x2F;&#x2F; nametrue 字符串碰见别的数据类型都是转换为字符串类型</span><br><span class="line">alert(undefined+1); &#x2F;&#x2F; NaN</span><br><span class="line">alert(typeof null); &#x2F;&#x2F; Object</span><br></pre></td></tr></table></figure>

<h2 id="Websocket和ajax的区别"><a href="#Websocket和ajax的区别" class="headerlink" title="Websocket和ajax的区别"></a>Websocket和ajax的区别</h2><ul>
<li>ajax是什么时候要用就什么时候请求后端数据；</li>
<li>Websocket是一直连接状态；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/31/17-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E3%80%81js%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/31/17-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E3%80%81js%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">17.事件委托、js继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-31 15:40:07 / Modified: 15:40:17" itemprop="dateCreated datePublished" datetime="2020-10-31T15:40:07+08:00">2020-10-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="请解释什么是事件代理，也就是事件委托"><a href="#请解释什么是事件代理，也就是事件委托" class="headerlink" title="请解释什么是事件代理，也就是事件委托"></a>请解释什么是事件代理，也就是事件委托</h2><ul>
<li>比如我们要给所有的ul下面的li添加事件，本身是给li添加事件，现在可以委托到ul上</li>
<li>即使后天加进来也有效</li>
<li>jq中很好用</li>
</ul>
<h2 id="说出几种js继承方式"><a href="#说出几种js继承方式" class="headerlink" title="说出几种js继承方式"></a>说出几种js继承方式</h2><ul>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承（上面两种）</li>
<li>寄生式继承</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
